@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

title OCR 识别流程 (OCR Recognition)

participant "PDF 解析器\npdf_parser.py" as Parser
participant "OCR 引擎\nocr.py" as OCR
participant "文本检测器\nTextDetector" as Detector
participant "文本识别器\nTextRecognizer" as Recognizer
participant "版面分析器\nLayoutRecognizer" as Layout
participant "OpenCV\n图像预处理" as CV

Parser -> Parser: __images__(fnm, zoomin=3)
activate Parser

note over Parser
遍历每一页 PDF，进行 OCR 识别
end note

== 1. 图像预处理 ==

Parser -> Parser: 渲染页面为图像\npage_image = page.to_image(\n  resolution=72 * zoomin,\n  antialias=True\n)

Parser -> Parser: 提取页面字符\npage_chars = page.dedupe_chars().chars

Parser -> Parser: 判断是否为英文页面\nis_english = re.search(\n  r"[ a-zA-Z0-9]{30,}",\n  sample_text\n)

note over Parser
如果页面字符稀疏或无法提取，\n则使用 OCR 识别所有文本
end note

== 2. 异步 OCR 处理 ==

loop 并行处理每一页

    Parser -> Parser: 创建异步任务\ntask = __img_ocr(\n  page_index=i,\n  img=page_image,\n  chars=page_chars,\n  zoomin=zoomin\n)

    note over Parser
    使用 asyncio 并行处理多页，\n通过 semaphore 控制并发数
    end note

    == 2.1 OCR 引擎调用 ==

    Parser -> OCR: __call__(img, device_id=0)
    activate OCR

    note over OCR
    主入口：文本检测 + 识别
    end note

    == 2.1.1 文本检测阶段 ==

    OCR -> Detector: text_detector(img)
    activate Detector

    Detector -> CV: 图像预处理\n- 灰度化 (cv2.cvtColor)\n- 二值化 (cv2.threshold)\n- 去噪 (cv2.fastNlMeansDenoising)
    activate CV

    CV --> Detector: preprocessed_img
    deactivate CV

    Detector -> Detector: 运行检测模型\ndet_model = PaddleOCR-Detection\nboxes = det_model.predict(img)

    note over Detector
    检测文本框的坐标：\n[[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
    end note

    Detector --> OCR: dt_boxes (N个文本框坐标)
    deactivate Detector

    alt 未检测到文本框

        OCR --> Parser: None (无文本)

    else 检测到文本框

        == 2.1.2 文本框排序 ==

        OCR -> OCR: sorted_boxes(dt_boxes)\n- 按 Y 坐标排序（行）\n- 按 X 坐标排序（列）

        note over OCR
        确保文本按阅读顺序排列
        end note

        == 2.1.3 文本框裁剪 ==

        loop 遍历每个文本框

            OCR -> OCR: 旋转裁剪图像\nimg_crop = get_rotate_crop_image(\n  ori_img,\n  box_coords\n)

            note over OCR
            处理倾斜文本，\n裁剪出单个文本区域
            end note

            OCR -> OCR: img_crop_list.append(img_crop)

        end

        == 2.1.4 文本识别阶段 ==

        OCR -> Recognizer: text_recognizer(img_crop_list)
        activate Recognizer

        Recognizer -> Recognizer: 批量识别\nloop 每个裁剪图像\n  text, score = rec_model.predict(img_crop)

        note over Recognizer
        识别模型：PaddleOCR-Recognition\n输出：(文本, 置信度)
        end note

        Recognizer --> OCR: rec_res = [\n  ("文字1", 0.98),\n  ("文字2", 0.95),\n  ...\n]
        deactivate Recognizer

        == 2.1.5 结果过滤 ==

        OCR -> OCR: 过滤低置信度结果\nloop 每个识别结果\n  if score >= drop_score:\n    filter_boxes.append(box)\n    filter_rec_res.append((text, score))

        note over OCR
        默认阈值：drop_score = 0.5
        end note

        OCR --> Parser: results = [\n  (box_coords, (text, score)),\n  ...\n]
        deactivate OCR

    end

    == 2.2 版面分析 (可选) ==

    alt 启用版面识别

        Parser -> Layout: layout_recognizer(img)
        activate Layout

        Layout -> Layout: 检测版面区域\nregions = model.predict(img)

        note over Layout
        13 种布局类型：\n- text, title, figure, table,\n- header, footer, reference, etc.
        end note

        Layout --> Parser: layout_regions = [\n  {"type": "text", "bbox": [...]},\n  {"type": "table", "bbox": [...]},\n  ...\n]
        deactivate Layout

        Parser -> Parser: 根据版面类型标记 OCR 结果\nfor box in ocr_results:\n  box["layout_type"] = find_region_type(box)

    end

    == 2.3 文本框处理 ==

    Parser -> Parser: 添加空格（英文）\nif is_english:\n  loop 相邻字符\n    if gap > threshold:\n      char["text"] += " "

    note over Parser
    英文单词间距检测，\n自动添加空格
    end note

    Parser -> Parser: 保存到 boxes\nself.boxes[page_index].append({\n  "text": text,\n  "x0": x0, "x1": x1,\n  "top": top, "bottom": bottom,\n  "page": page_index,\n  "layout_type": layout_type,\n  "score": confidence\n})

end

== 3. OCR 结果汇总 ==

Parser -> Parser: 累积页面高度\npage_cum_height = np.cumsum(page_heights)

note over Parser
用于多页文档的全局坐标定位
end note

Parser -> Parser: 判断整体语言\nif most_pages_english:\n  is_english = True

Parser -> Parser: 返回识别结果\nreturn boxes (所有页面的文本框)

deactivate Parser

note over Parser
OCR 结果包含：\n- 文本内容和坐标\n- 置信度\n- 版面类型\n- 页码信息
end note

@enduml
