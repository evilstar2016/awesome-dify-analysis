@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

title PDF 文档解析流程 (PDF Parsing)

participant "解析任务\nWorker" as Worker
participant "PDF Parser\npdf_parser.py" as Parser
participant "版面分析器\nLayoutAnalyzer" as Layout
participant "OCR 引擎\nPaddleOCR" as OCR
participant "表格提取器\nCamelot" as Table
participant "图像处理\nImageProcessor" as Image

Worker -> Parser: parse_pdf(\n  file_path="doc.pdf",\n  config={...}\n)
activate Parser

== 1. 文件加载 ==

Parser -> Parser: 打开 PDF\npdf = pdfplumber.open(file_path)\ndoc = fitz.open(file_path)

Parser -> Parser: 获取元数据\nmetadata = {\n  "pages": pdf.pages,\n  "title": doc.metadata["title"],\n  "author": doc.metadata["author"]\n}

== 2. 逐页处理 ==

loop 遍历每一页
    Parser -> Parser: 获取页面\npage = pdf.pages[page_num]\nfitz_page = doc[page_num]
    
    == 2.1 版面分析 ==
    
    Parser -> Layout: analyze_layout(\n  page_image=fitz_page.get_pixmap()\n)
    activate Layout
    
    Layout -> Layout: 检测区域类型\nregions = [\n  {"type": "text", "bbox": [...]},\n  {"type": "table", "bbox": [...]},\n  {"type": "image", "bbox": [...]}\n]
    
    Layout --> Parser: 返回版面信息\nregions
    deactivate Layout
    
    == 2.2 文本提取 ==
    
    loop 每个文本区域
        Parser -> Parser: 提取文本\ntext = page.extract_text(\n  x0=region["bbox"][0],\n  y0=region["bbox"][1],\n  x1=region["bbox"][2],\n  y1=region["bbox"][3]\n)
        
        Parser -> Parser: 文本清洗\ntext = clean_text(text)\n  - 去除多余空格\n  - 修复换行\n  - 统一编码
        
        Parser -> Parser: 保存文本块\ntext_blocks.append({\n  "type": "text",\n  "content": text,\n  "bbox": region["bbox"],\n  "page": page_num\n})
    end
    
    == 2.3 表格提取 ==
    
    loop 每个表格区域
        Parser -> Table: extract_table(\n  page_num=page_num,\n  bbox=region["bbox"]\n)
        activate Table
        
        Table -> Table: 检测表格边界\ntables = camelot.read_pdf(\n  file_path,\n  pages=str(page_num),\n  flavor='lattice'\n)
        
        Table -> Table: 提取表格数据\ndf = tables[0].df
        
        Table -> Table: 转换为 Markdown\nmarkdown = df.to_markdown()
        
        Table --> Parser: 返回表格\n{\n  "type": "table",\n  "content": markdown,\n  "rows": 10,\n  "cols": 5\n}
        deactivate Table
        
        Parser -> Parser: 保存表格块\ntable_blocks.append(table_data)
    end
    
    == 2.4 图像处理 ==
    
    loop 每个图像区域
        Parser -> Parser: 提取图片\nimage = fitz_page.get_pixmap(\n  clip=region["bbox"]\n)
        
        Parser -> Image: preprocess(\n  image=image\n)
        activate Image
        
        Image -> Image: 图像增强\n- 去噪 (cv2.fastNlMeansDenoising)\n- 二值化 (cv2.threshold)\n- 倾斜校正
        
        Image --> Parser: 返回增强图片\nenhanced_image
        deactivate Image
        
        Parser -> OCR: ocr(\n  image=enhanced_image\n)
        activate OCR
        
        OCR -> OCR: 文字检测\nboxes = det_model(image)
        
        OCR -> OCR: 文字识别\nloop 每个文本框\n  text = rec_model(crop(image, box))
        
        OCR --> Parser: 返回 OCR 结果\n[\n  {"text": "图片中的文字", "confidence": 0.95},\n  ...\n]
        deactivate OCR
        
        Parser -> Parser: 保存图片块\nimage_blocks.append({\n  "type": "image",\n  "ocr_text": ocr_results,\n  "bbox": region["bbox"],\n  "page": page_num\n})
    end
end

== 3. 内容合并 ==

Parser -> Parser: 按阅读顺序排序\nall_blocks = sort_by_position(\n  text_blocks + table_blocks + image_blocks\n)

Parser -> Parser: 合并连续文本\nfor i, block in enumerate(all_blocks):\n  if is_continuation(block, all_blocks[i-1]):\n    merge_blocks(block, all_blocks[i-1])

Parser -> Parser: 生成最终内容\ncontent = ""\nfor block in all_blocks:\n  if block["type"] == "text":\n    content += block["content"] + "\\n\\n"\n  elif block["type"] == "table":\n    content += block["content"] + "\\n\\n"\n  elif block["type"] == "image":\n    content += f"[图片: {block['ocr_text']}]\\n\\n"

== 4. 返回结果 ==

Parser --> Worker: 返回解析结果\n{\n  "content": content,\n  "metadata": metadata,\n  "blocks": all_blocks,\n  "pages": len(pdf.pages)\n}
deactivate Parser

note right of Layout
  版面分析方法：
  
  1. 基于规则
     - 坐标分析
     - 字体大小
     - 颜色区分
  
  2. 深度学习
     - LayoutLM
     - YOLO 目标检测
     - Detectron2
end note

note right of OCR
  OCR 引擎选择：
  
  - PaddleOCR (默认)
    * 速度快
    * 中英文准确率高
  
  - Tesseract
    * 多语言支持
    * 开源免费
  
  - RapidOCR
    * 轻量级
    * CPU 友好
end note

note left of Table
  表格提取策略：
  
  1. Lattice (有边框)
     - 检测表格线
     - 提取单元格
  
  2. Stream (无边框)
     - 基于文本对齐
     - 空格分隔
  
  3. 深度学习
     - Table Transformer
     - 端到端识别
end note

@enduml
