@startuml Workflow Management Core Scenarios Sequence Diagram
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

title Dify Workflow Management Core Scenarios Sequence Diagram

actor "User" as User
participant "Frontend Interface\n(React/Next.js)" as Frontend #E3F2FD
participant "Workflow Controller\n(Flask API)" as Controller #E8F5E9
participant "Workflow Service\n(WorkflowService)" as Service #E8F5E9
participant "App Generate Service\n(AppGenerateService)" as AppGen #E8F5E9
participant "Workflow Entry\n(WorkflowEntry)" as Entry #FFF3E0
participant "Graph Execution Engine\n(GraphEngine)" as Engine #FFF3E0
participant "Dispatcher\n(Dispatcher)" as Dispatcher #FFF3E0
participant "Worker Pool\n(WorkerPool)" as WorkerPool #FFF3E0
participant "Node Executor\n(Node)" as Node #FFEBEE
participant "Event Manager\n(EventManager)" as EventMgr #FCE4EC
participant "Command Channel\n(CommandChannel)" as CmdChannel #F3E5F5
database "PostgreSQL" as DB #BBDEFB
database "Redis" as Cache #C8E6C9

== Workflow Creation/Editing Phase ==
User -> Frontend ++: Create/Edit Workflow
Frontend -> Frontend: Initialize workflow state\n(hooks-store)
Frontend -> Controller ++: POST /apps/{id}/workflows/draft
note right of Controller
**DraftWorkflowApi.post()**
Parse graph/features configuration
Validate environment variables
end note
Controller -> Service ++: sync_draft_workflow()
Service -> Service: validate_features_structure()
Service -> DB ++: Create/Update Workflow record
DB --> Service --: Return workflow object
Service --> Controller --: Return workflow + hash
Controller --> Frontend --: {result, hash, updated_at}
Frontend -> Frontend: Update local state
Frontend --> User --: Display editor

== Workflow Publishing Phase ==
User -> Frontend ++: Publish Workflow
Frontend -> Controller ++: POST /apps/{id}/workflows/publish
Controller -> Service ++: publish_workflow()
Service -> Service: _validate_workflow_credentials()
Service -> DB ++: Create new version Workflow
DB --> Service --: Return published workflow
Service -> Service: app_published_workflow_was_updated event
Service --> Controller --: Return publish result
Controller --> Frontend --: Publish successful
Frontend --> User --: Display publish status

== Workflow Execution Phase ==
User -> Frontend ++: Click run workflow
Frontend -> Frontend: handleStartWorkflowRun()
Frontend -> Controller ++: POST /workflows/draft/run
note right of Controller
**DraftWorkflowRunApi.post()**
Parse inputs/files parameters
end note
Controller -> AppGen ++: generate()
note right of AppGen
Create task queue manager
Initialize workflow runner
end note

AppGen -> Entry ++: Create WorkflowEntry instance
note right of Entry
**Initialization parameters:**
• tenant_id, app_id
• graph configuration
• variable_pool
• command_channel
end note

Entry -> Entry: Check call_depth limit
Entry -> Engine ++: Create GraphEngine instance
note right of Engine
**GraphEngine initialization:**
• GraphStateManager
• ReadyQueue
• EventManager
• EdgeProcessor
• SkipPropagator
• CommandProcessor
• WorkerPool
end note

Engine -> Engine: _validate_graph_state_consistency()
Engine -> Engine: Add execution layers\n- DebugLoggingLayer\n- ExecutionLimitsLayer

AppGen -> Entry: run()
Entry -> Engine: run()

Engine -> EventMgr: Initialize Layers
Engine -> EventMgr ++: GraphRunStartedEvent
EventMgr --> Controller: Push event (SSE)
Controller --> Frontend: Real-time update status
Frontend --> User: Display execution start

Engine -> Engine: _start_execution()
Engine -> WorkerPool ++: start()
note right of WorkerPool
**Dynamic worker pool:**
min_workers, max_workers
scale_up_threshold
end note
Engine -> Dispatcher ++: start()

loop Node execution loop
    Dispatcher -> WorkerPool: Get ready nodes
    WorkerPool -> Node ++: Execute node

    alt Node execution successful
        Node -> Node: _run() execute business logic
        Node --> WorkerPool --: NodeRunResult
        WorkerPool -> EventMgr: NodeRunSucceededEvent
        EventMgr --> Controller: Push event
        Controller --> Frontend: Update node status
        Frontend --> User: Display node completion

        Dispatcher -> Engine: EdgeProcessor process subsequent edges
        Engine -> Engine: Conditional branch evaluation\nSkipPropagator skip processing
        Engine -> Engine: Enqueue next batch of nodes

    else Node execution failed
        Node --> WorkerPool --: Error information
        WorkerPool -> EventMgr: NodeRunFailedEvent
        EventMgr --> Controller: Push error
        Controller --> Frontend: Display error
        Frontend --> User: Error prompt

        alt ErrorStrategy.FAIL_BRANCH
            Engine -> Engine: Take failure branch
        else ErrorStrategy.CONTINUE
            Engine -> Engine: Continue execution
        else ErrorStrategy.STOP
            Engine -> Engine: Stop execution
        end
    end

    Dispatcher -> CmdChannel: Check external commands
    alt Received AbortCommand
        CmdChannel --> Dispatcher: AbortCommand
        Dispatcher -> Engine: Mark aborted
        Engine -> EventMgr: GraphRunAbortedEvent
    else Received PauseCommand
        CmdChannel --> Dispatcher: PauseCommand
        Dispatcher -> Engine: Mark paused
        Engine -> EventMgr: GraphRunPausedEvent
    end
end

alt Execution successful
    Engine -> EventMgr: GraphRunSucceededEvent
    EventMgr --> Entry --: outputs
    Entry --> AppGen --: Execution result
    AppGen -> DB ++: Save WorkflowRun record
    DB --> AppGen --: Save successful
    AppGen --> Controller --: Return result
    Controller --> Frontend --: Execution completed
    Frontend --> User --: Display result

else Partial success
    Engine -> EventMgr: GraphRunPartialSucceededEvent
    EventMgr --> Entry --: outputs + exceptions_count
    Entry --> AppGen --: Partial success result
    AppGen --> Controller --: Return partial result
    Controller --> Frontend --: Partial completion
    Frontend --> User --: Display partial result

else Execution failed
    Engine -> EventMgr: GraphRunFailedEvent
    EventMgr --> Entry --: Error information
    Entry --> AppGen --: Failure information
    AppGen -> DB ++: Record failure status
    DB --> AppGen --: Record completed
    AppGen --> Controller --: Return error
    Controller --> Frontend --: Execution failed
    Frontend --> User --: Display error information
end

Engine -> Dispatcher --: stop()
Engine -> WorkerPool --: stop()

== Workflow Stop Phase ==
User -> Frontend ++: Click stop
Frontend -> Controller ++: POST /workflows/tasks/{task_id}/stop
Controller -> CmdChannel ++: GraphEngineManager.send_stop_command()
note right of CmdChannel
**RedisChannel send command:**
channel_key = workflow:{task_id}:commands
AbortCommand(reason)
end note
CmdChannel -> Cache ++: Publish stop command
Cache --> CmdChannel --: Publish successful
CmdChannel --> Controller --: Command sent
Controller --> Frontend --: Stop request submitted
Frontend --> User --: Display stopping

== Single Node Debug Execution ==
User -> Frontend ++: Single step debug node
Frontend -> Controller ++: POST /workflows/draft/nodes/{id}/run
Controller -> Service ++: single_step_run()
Service -> Entry: WorkflowEntry.single_step_run()
Entry -> Entry: Get node configuration
Entry -> Entry: Initialize GraphInitParams
Entry -> Node ++: Create node instance
Node -> Node: init_node_data()
Node -> Node: extract_variable_selector_to_variable_mapping()
Entry -> Entry: mapping_user_inputs_to_variable_pool()
Entry -> Node: run()
Node --> Entry --: Generator[NodeEvent]
Entry --> Service --: (node, generator)
Service --> Controller --: Node execution result
Controller --> Frontend --: Return result
Frontend --> User --: Display node output

== Core Technical Components Description ==

note right of Frontend
**Frontend Technology Stack**
━━━━━━━━━━━━━━━━
• React 19 + TypeScript
• Next.js 15 App Router
• Zustand state management
• React Flow workflow canvas
• SSE real-time event push
• hooks-store centralized management
end note

note right of Controller
**API Layer Components**
━━━━━━━━━━━━━━━━
• Flask-RESTX API framework
• JWT authentication middleware
• Request parameter parsing
• Response serialization
• Error handling decorators
end note

note right of Engine
**Graph Execution Engine Core**
━━━━━━━━━━━━━━━━
• GraphStateManager: Node state management
• ReadyQueue: Ready node queue
• EdgeProcessor: Edge processing/conditional branching
• SkipPropagator: Skip propagation
• ResponseCoordinator: Response coordination
• Layer system: Pluggable middleware
end note

note right of WorkerPool
**Worker Pool Management**
━━━━━━━━━━━━━━━━
• Dynamic thread pool scaling
• Flask context passing
• contextvars propagation
• Concurrent execution control
end note

note right of Node
**Node Types**
━━━━━━━━━━━━━━━━
• StartNode: Start node
• LLMNode: LLM call
• AgentNode: Agent
• CodeNode: Code execution
• IfElseNode: Conditional branch
• IterationNode: Iteration loop
• LoopNode: Loop node
• ToolNode: Tool call
• KnowledgeRetrievalNode: Knowledge retrieval
• AnswerNode: Answer output
• EndNode: End node
end note

note right of CmdChannel
**Command Channel**
━━━━━━━━━━━━━━━━
• InMemoryChannel: In-process communication
• RedisChannel: Distributed communication
• Supported commands: Abort, Pause
end note

note right of DB
**Data Models**
━━━━━━━━━━━━━━━━
• Workflow: Workflow definition
• WorkflowRun: Execution record
• WorkflowNodeExecution: Node execution
• VariablePool: Variable storage
end note

@enduml