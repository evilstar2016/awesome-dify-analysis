# 消息平台集成

## 1. 集成概述

Dify 支持通过 OAuth 认证和 Webhook 机制集成各类消息平台，实现 AI 应用与企业通讯工具的无缝对接。

### 核心价值

- **OAuth 认证**: 安全的第三方授权机制
- **Webhook 支持**: 实时接收平台事件通知
- **多平台支持**: 可扩展到各类消息平台
- **工具集成**: 通过工具系统实现平台功能调用

## 2. 支持的服务/产品

| 平台类型 | 状态 | 说明 |
|---------|------|------|
| Webhook (通用) | ✅ 支持 | HTTP Webhook 通用集成 |
| OAuth 2.0 | ✅ 支持 | 标准 OAuth 2.0 认证流程 |
| 自定义工具 | ✅ 支持 | 通过工具系统集成第三方 API |

### 2.1 可通过工具集成的平台

以下平台可通过 Dify 的内置工具或自定义工具进行集成：

- 钉钉 (DingTalk)
- 企业微信 (WeChat Work)
- 飞书/Lark
- Slack
- Discord
- Telegram
- 其他支持 API 的平台

## 3. 集成方式

### 3.1 架构设计

```
┌─────────────────────────────────────────────────────┐
│                 Application Layer                    │
├─────────────────────────────────────────────────────┤
│              OAuth & Webhook Layer                   │
│  ┌───────────────────────────────────────────────┐  │
│  │         OAuth Manager                         │  │
│  │  - 授权流程管理                               │  │
│  │  - Token 管理和刷新                           │  │
│  │  - 凭证加密存储                               │  │
│  └───────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────┐  │
│  │        Webhook Handler                        │  │
│  │  - 接收 Webhook 请求                          │  │
│  │  - 签名验证                                   │  │
│  │  - 事件分发                                   │  │
│  └───────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────┤
│              Tool System Integration                 │
│  ┌───────────────────────────────────────────────┐  │
│  │        Custom Tool / API Tool                 │  │
│  │  - HTTP 请求构建                              │  │
│  │  - 认证信息注入                               │  │
│  │  - 响应解析                                   │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

### 3.2 OAuth 集成流程

```
用户 -> Dify -> 第三方平台 -> 授权页面 -> 用户授权
                                           ↓
                                      授权码 (code)
                                           ↓
Dify <- 第三方平台 <- 换取 Access Token <- 授权码
     ↓
存储 Token (加密)
     ↓
使用 Token 调用 API
```

### 3.3 Webhook 集成流程

```
第三方平台事件发生
     ↓
发送 Webhook 请求到 Dify
     ↓
Dify 验证签名
     ↓
解析事件类型
     ↓
触发对应的处理逻辑
     ↓
返回响应给第三方平台
```

## 4. 代码实现

### 4.1 核心代码路径

```
api/models/
├── oauth.py                    # OAuth 模型定义
│   ├── DatasourceOauthParamConfig
│   └── DatasourceProvider
├── source.py                   # 数据源绑定
│   ├── DataSourceOauthBinding
│   └── DataSourceApiKeyAuthBinding
└── tools.py                    # 工具 OAuth 配置
    └── ToolOAuthSystemClient

api/core/tools/
├── utils/
│   └── system_oauth_encryption.py  # OAuth 参数加密
├── custom_tool/                    # 自定义工具（支持 OAuth）
└── builtin_tool/                   # 内置工具

api/controllers/
└── web/                        # Webhook 接收端点
```

### 4.2 OAuth 模型

```python
# api/models/oauth.py
class DatasourceOauthParamConfig(Base):
    """OAuth parameter configuration"""
    
    provider: str  # 提供商名称
    oauth_type: str  # OAuth 类型
    oauth_params: str  # OAuth 参数（JSON）
    encrypted_oauth_params: str  # 加密的 OAuth 参数
```

```python
class DataSourceOauthBinding(Base):
    """OAuth binding for data source"""
    
    tenant_id: str
    provider: str
    access_token: str  # 访问令牌
    refresh_token: str  # 刷新令牌（可选）
    expires_at: datetime  # 过期时间
    scope: str  # 授权范围
```

### 4.3 OAuth 加密

```python
# api/core/tools/utils/system_oauth_encryption.py
def encrypt_system_oauth_params(oauth_params: dict) -> str:
    """Encrypt OAuth parameters"""
    # 使用应用密钥加密
    pass

def decrypt_system_oauth_params(encrypted_params: str) -> dict:
    """Decrypt OAuth parameters"""
    # 解密 OAuth 参数
    pass
```

## 5. 使用示例

### 5.1 配置 OAuth 客户端

```bash
# 使用 CLI 配置 OAuth 客户端
uv run --project api python -m flask setup-system-tool-oauth-client \
    --provider my_platform \
    --client-params '{"client_id":"xxx","client_secret":"yyy"}'
```

### 5.2 实现 OAuth 授权流程

```python
from flask import redirect, request
from libs.passport import PassportService

@app.route('/oauth/authorize')
def oauth_authorize():
    """发起 OAuth 授权"""
    provider = request.args.get('provider')
    
    # 构建授权 URL
    auth_url = f"https://oauth.{provider}.com/authorize"
    params = {
        'client_id': 'your_client_id',
        'redirect_uri': 'https://your-domain.com/oauth/callback',
        'response_type': 'code',
        'scope': 'read write',
        'state': generate_random_state()
    }
    
    return redirect(f"{auth_url}?{urlencode(params)}")

@app.route('/oauth/callback')
def oauth_callback():
    """OAuth 回调处理"""
    code = request.args.get('code')
    state = request.args.get('state')
    
    # 验证 state
    if not verify_state(state):
        return "Invalid state", 400
    
    # 换取 access token
    token_response = requests.post(
        'https://oauth.provider.com/token',
        data={
            'grant_type': 'authorization_code',
            'code': code,
            'client_id': 'your_client_id',
            'client_secret': 'your_client_secret',
            'redirect_uri': 'https://your-domain.com/oauth/callback'
        }
    )
    
    token_data = token_response.json()
    
    # 存储 token
    save_oauth_token(
        provider='provider_name',
        access_token=token_data['access_token'],
        refresh_token=token_data.get('refresh_token'),
        expires_in=token_data['expires_in']
    )
    
    return "授权成功"
```

### 5.3 使用 OAuth Token 调用 API

```python
def call_api_with_oauth(provider, endpoint, **kwargs):
    """使用 OAuth Token 调用 API"""
    # 获取 token
    binding = get_oauth_binding(provider)
    
    # 检查是否过期
    if binding.is_expired():
        # 刷新 token
        binding = refresh_oauth_token(binding)
    
    # 调用 API
    headers = {
        'Authorization': f'Bearer {binding.access_token}'
    }
    
    response = requests.get(
        f"https://api.{provider}.com/{endpoint}",
        headers=headers,
        **kwargs
    )
    
    return response.json()
```

### 5.4 配置 Webhook 接收

```python
@app.route('/webhook/<provider>', methods=['POST'])
def webhook_handler(provider):
    """Webhook 处理"""
    # 获取请求数据
    data = request.get_json()
    
    # 验证签名
    signature = request.headers.get('X-Signature')
    if not verify_webhook_signature(provider, data, signature):
        return "Invalid signature", 403
    
    # 处理事件
    event_type = data.get('event_type')
    
    if event_type == 'message':
        handle_message_event(data)
    elif event_type == 'user_action':
        handle_user_action_event(data)
    
    return {"status": "ok"}

def verify_webhook_signature(provider, data, signature):
    """验证 Webhook 签名"""
    secret = get_webhook_secret(provider)
    expected_signature = hmac.new(
        secret.encode(),
        json.dumps(data).encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(expected_signature, signature)
```

### 5.5 通过自定义工具集成

```python
# 创建自定义 API 工具
from core.tools.custom_tool import CustomTool

class MessagePlatformTool(CustomTool):
    """消息平台工具"""
    
    def _invoke(self, user_id: str, tool_parameters: dict):
        """发送消息到平台"""
        message = tool_parameters.get('message')
        channel = tool_parameters.get('channel')
        
        # 使用 OAuth token
        result = call_api_with_oauth(
            provider='message_platform',
            endpoint=f'channels/{channel}/messages',
            method='POST',
            json={'text': message}
        )
        
        return self.create_text_message(f"消息已发送: {result}")
```

## 6. 错误处理

### 6.1 Token 过期处理

```python
def handle_token_expired(binding):
    """处理 Token 过期"""
    try:
        # 尝试刷新 token
        new_token = refresh_oauth_token(
            provider=binding.provider,
            refresh_token=binding.refresh_token
        )
        
        # 更新存储
        binding.access_token = new_token['access_token']
        binding.refresh_token = new_token.get('refresh_token', binding.refresh_token)
        binding.expires_at = datetime.now() + timedelta(seconds=new_token['expires_in'])
        db.session.commit()
        
        return binding
    except Exception as e:
        logger.error(f"Token refresh failed: {e}")
        # 需要重新授权
        raise OAuthTokenExpiredError("请重新授权")
```

### 6.2 API 调用错误处理

```python
def safe_api_call(provider, endpoint, **kwargs):
    """安全的 API 调用"""
    max_retries = 3
    
    for attempt in range(max_retries):
        try:
            return call_api_with_oauth(provider, endpoint, **kwargs)
        except OAuthTokenExpiredError:
            # Token 过期，刷新后重试
            refresh_oauth_token(provider)
            continue
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise
            time.sleep(2 ** attempt)  # 指数退避
```

## 7. 性能优化

### 7.1 Token 缓存

```python
from extensions.ext_redis import redis_client

def get_cached_token(provider, user_id):
    """从缓存获取 token"""
    cache_key = f"oauth:token:{provider}:{user_id}"
    cached = redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    # 从数据库获取
    binding = get_oauth_binding(provider, user_id)
    
    # 缓存到 Redis
    redis_client.setex(
        cache_key,
        3600,  # 1小时
        json.dumps({
            'access_token': binding.access_token,
            'expires_at': binding.expires_at.isoformat()
        })
    )
    
    return binding
```

### 7.2 Webhook 异步处理

```python
from celery import Celery

@app.route('/webhook/<provider>', methods=['POST'])
def webhook_handler(provider):
    """异步处理 Webhook"""
    data = request.get_json()
    
    # 快速验证并返回
    if not verify_webhook_signature(provider, data, request.headers.get('X-Signature')):
        return "Invalid signature", 403
    
    # 异步处理
    process_webhook_async.delay(provider, data)
    
    return {"status": "ok"}

@celery.task
def process_webhook_async(provider, data):
    """异步处理 Webhook 数据"""
    event_type = data.get('event_type')
    # 处理逻辑
```

## 8. 监控与日志

### 8.1 OAuth 流程监控

```python
import logging

logger = logging.getLogger(__name__)

def log_oauth_event(event_type, provider, user_id, success=True, error=None):
    """记录 OAuth 事件"""
    log_data = {
        'event_type': event_type,
        'provider': provider,
        'user_id': user_id,
        'success': success,
        'timestamp': datetime.now().isoformat()
    }
    
    if error:
        log_data['error'] = str(error)
        logger.error(f"OAuth event failed: {log_data}")
    else:
        logger.info(f"OAuth event: {log_data}")
```

### 8.2 Webhook 监控

```python
def log_webhook_event(provider, event_type, success=True):
    """记录 Webhook 事件"""
    logger.info(f"Webhook received - Provider: {provider}, Type: {event_type}, Success: {success}")
```

## 9. 测试

### 9.1 OAuth 流程测试

```python
import pytest
from unittest.mock import Mock, patch

@patch('requests.post')
def test_oauth_token_exchange(mock_post):
    mock_post.return_value.json.return_value = {
        'access_token': 'test_token',
        'refresh_token': 'test_refresh',
        'expires_in': 3600
    }
    
    result = exchange_oauth_code('test_code', 'provider')
    
    assert result['access_token'] == 'test_token'
    assert mock_post.called
```

### 9.2 Webhook 签名验证测试

```python
def test_webhook_signature_verification():
    data = {'event': 'test'}
    secret = 'test_secret'
    
    # 生成签名
    signature = generate_webhook_signature(data, secret)
    
    # 验证签名
    assert verify_webhook_signature('provider', data, signature) == True
    
    # 验证错误签名
    assert verify_webhook_signature('provider', data, 'wrong_sig') == False
```

## 10. 扩展新平台

### 10.1 添加 OAuth 提供商配置

```python
# 在数据库中添加提供商配置
provider_config = DatasourceOauthParamConfig(
    provider='new_platform',
    oauth_type='oauth2',
    oauth_params=json.dumps({
        'authorization_url': 'https://platform.com/oauth/authorize',
        'token_url': 'https://platform.com/oauth/token',
        'scope': 'read write'
    })
)
db.session.add(provider_config)
db.session.commit()
```

### 10.2 实现平台特定的 API 工具

```python
from core.tools.custom_tool import CustomTool

class NewPlatformTool(CustomTool):
    """新平台工具"""
    
    def _invoke(self, user_id: str, tool_parameters: dict):
        # 获取 OAuth token
        binding = get_oauth_binding('new_platform', user_id)
        
        # 调用平台 API
        result = call_platform_api(
            binding.access_token,
            tool_parameters
        )
        
        return self.create_text_message(f"操作完成: {result}")
```

## 11. 最佳实践

### 11.1 安全性

- 始终使用 HTTPS
- 加密存储敏感信息
- 验证 Webhook 签名
- 实施速率限制
- 使用最小权限范围

### 11.2 可靠性

- 实现 Token 自动刷新
- 处理 API 限流
- 异步处理 Webhook
- 实施重试机制
- 记录详细日志

### 11.3 用户体验

- 提供清晰的授权说明
- 优化授权流程
- 及时通知授权状态
- 支持授权解除

## 12. 参考资源

- [OAuth 2.0 RFC 6749](https://tools.ietf.org/html/rfc6749)
- [Webhook 最佳实践](https://github.com/webhooks/webhooks)
- [Dify 工具开发文档](../../api/core/tools/README.md)
