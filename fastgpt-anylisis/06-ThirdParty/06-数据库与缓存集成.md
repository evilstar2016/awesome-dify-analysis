# 数据库与缓存集成

FastGPT 使用多种数据库和缓存服务来支撑其核心功能。

## 一、支持的数据库

| 数据库 | 状态 | 用途 |
|--------|------|------|
| **MongoDB** | ✅ 必需 | 主数据存储、日志存储 |
| **Redis** | ✅ 必需 | 缓存、消息队列、会话管理 |
| **PostgreSQL** | ✅ 可选 | 向量存储（PGVector） |
| **MySQL/OceanBase** | ✅ 可选 | 向量存储 |

## 二、MongoDB 集成

### 2.1 环境配置

```bash
# MongoDB 主数据库
MONGODB_URI=mongodb://username:password@host:27017/fastgpt

# MongoDB 日志数据库（可选，用于日志隔离）
MONGODB_LOG_URI=mongodb://username:password@host:27017/fastgpt_log
```

### 2.2 连接管理（`packages/service/common/mongo/index.ts`）

```typescript
import Mongoose from 'mongoose';

declare global {
  var mongodb: Mongoose | undefined;
  var mongodbLog: Mongoose | undefined;
}

// 主数据库连接
export const connectionMongo = (() => {
  if (!global.mongodb) {
    global.mongodb = new Mongoose();
  }
  return global.mongodb;
})();

// 日志数据库连接
export const connectionLogMongo = (() => {
  if (!global.mongodbLog) {
    global.mongodbLog = new Mongoose();
  }
  return global.mongodbLog;
})();

// 中间件
const addCommonMiddleware = (schema: mongoose.Schema) => {
  // 自动添加 createdAt, updatedAt
  schema.pre('save', function(next) {
    if (this.isNew) {
      this.createdAt = new Date();
    }
    this.updatedAt = new Date();
    next();
  });
};
```

### 2.3 数据模型定义

```typescript
// Schema 定义示例
import { Schema, getMongoModel } from '../mongo';

const UserSchema = new Schema({
  username: String,
  email: String,
  // ...
});

export const MongoUser = getMongoModel('users', UserSchema);
```

### 2.4 主要集合

- **核心集合**：
  - `users` - 用户信息
  - `teams` - 团队信息
  - `apps` - 应用配置
  - `datasets` - 数据集
  - `chat_histories` - 对话历史

- **日志集合**（mongodbLog）：
  - `chat_logs` - 对话日志
  - `usage_logs` - 使用日志
  - `audit_logs` - 审计日志

## 三、Redis 集成

### 3.1 环境配置

```bash
# Redis 连接 URL
REDIS_URL=redis://localhost:6379
```

### 3.2 连接管理（`packages/service/common/redis/index.ts`）

```typescript
import Redis from 'ioredis';

const REDIS_URL = process.env.REDIS_URL ?? 'redis://localhost:6379';
export const FASTGPT_REDIS_PREFIX = 'fastgpt:';

declare global {
  var redisClient: Redis | null;
}

// 全局 Redis 客户端
export const getGlobalRedisConnection = () => {
  if (global.redisClient) return global.redisClient;
  
  global.redisClient = new Redis(REDIS_URL, { 
    keyPrefix: FASTGPT_REDIS_PREFIX 
  });
  
  global.redisClient.on('connect', () => {
    console.log('Redis connected');
  });
  
  global.redisClient.on('error', (error) => {
    console.error('Redis connection error', error);
  });
  
  return global.redisClient;
};

// 队列专用连接
export const newQueueRedisConnection = () => {
  const redis = new Redis(REDIS_URL);
  redis.on('connect', () => {
    console.log('Redis connected');
  });
  redis.on('error', (error) => {
    console.error('Redis connection error', error);
  });
  return redis;
};

// Worker 专用连接
export const newWorkerRedisConnection = () => {
  const redis = new Redis(REDIS_URL, {
    maxRetriesPerRequest: null
  });
  redis.on('connect', () => {
    console.log('Redis connected');
  });
  redis.on('error', (error) => {
    console.error('Redis connection error', error);
  });
  return redis;
};
```

### 3.3 缓存管理（`packages/service/common/redis/cache.ts`）

```typescript
const redisPrefix = 'cache:';
const getCacheKey = (key: string) => `${redisPrefix}${key}`;

export enum CacheKeyEnum {
  team_vector_count = 'team_vector_count',
  // ... 其他缓存键
}

// 设置缓存
export const setRedisCache = async (
  key: string,
  data: string,
  expireSeconds?: number
) => {
  return await retryFn(async () => {
    try {
      const redis = getGlobalRedisConnection();
      if (expireSeconds) {
        await redis.set(getCacheKey(key), data, 'EX', expireSeconds);
      } else {
        await redis.set(getCacheKey(key), data);
      }
    } catch (error) {
      console.error('Set cache error:', error);
    }
  });
};

// 获取缓存
export const getRedisCache = async (key: string) => {
  const redis = getGlobalRedisConnection();
  return retryFn(() => redis.get(getCacheKey(key)));
};

// 增加缓存值
export const incrValueToCache = async (key: string, increment: number) => {
  if (typeof increment !== 'number' || increment === 0) return;
  const redis = getGlobalRedisConnection();
  try {
    await retryFn(() => redis.incrbyfloat(getCacheKey(key), increment));
  } catch (error) {}
};

// 删除缓存
export const delRedisCache = async (key: string) => {
  const redis = getGlobalRedisConnection();
  await retryFn(() => redis.del(getCacheKey(key)));
};

// 追加缓存
export const appendRedisCache = async (
  key: string,
  value: string,
  expireSeconds?: number
) => {
  try {
    const redis = getGlobalRedisConnection();
    await retryFn(() => redis.append(getCacheKey(key), value));
    if (expireSeconds) {
      await redis.expire(getCacheKey(key), expireSeconds);
    }
  } catch (error) {
    console.error('Append cache error:', error);
  }
};
```

### 3.4 频率限制（`packages/service/common/api/frequencyLimit.ts`）

```typescript
export const teamFrequencyLimit = async ({ teamId, type, res }: FrequencyLimitOption) => {
  const { seconds, limit } = limitMap[type];
  const redis = getGlobalRedisConnection();
  const key = `frequency:${type}:${teamId}`;
  
  const result = await redis
    .multi()
    .incr(key)
    .expire(key, seconds, 'NX')  // 只在key不存在时设置过期时间
    .exec();
  
  const currentCount = result?.[0]?.[1] as number;
  
  if (currentCount > limit) {
    const remainingTime = await redis.ttl(key);
    jsonRes(res, {
      code: 429,
      error: `Rate limit exceeded. Maximum ${limit} requests per ${seconds} seconds for this team. Please try again in ${remainingTime} seconds.`
    });
    return Promise.reject('Frequency limit');
  }
};
```

### 3.5 系统缓存（`packages/service/common/cache/index.ts`）

```typescript
const cachePrefix = 'system:cache:';

// 刷新版本键（用于缓存失效）
export const refreshVersionKey = async (key: `${SystemCacheKeyEnum}`, id?: string | '*') => {
  const redis = getGlobalRedisConnection();
  if (!global.systemCache) initCache();
  
  const val = randomUUID();
  
  if (id === '*') {
    // 清除所有相关缓存
    const pattern = `${cachePrefix}${key}:*`;
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(keys);
    }
  } else {
    await redis.set(versionKey, val);
  }
};

// 获取版本键
export const getVersionKey = async (key: `${SystemCacheKeyEnum}`, id?: string) => {
  const redis = getGlobalRedisConnection();
  if (!global.systemCache) initCache();
  
  const versionKey = id ? `${cachePrefix}${key}:${id}` : `${cachePrefix}${key}`;
  const val = await redis.get(versionKey);
  if (val) return val;
  
  // if there is no val set to the key, init a new val.
  const initVal = randomUUID();
  await redis.set(versionKey, initVal);
  return initVal;
};
```

## 四、BullMQ 队列集成

### 4.1 队列定义（`packages/service/common/bullmq/index.ts`）

```typescript
import { Queue, Worker, ConnectionOptions } from 'bullmq';
import { newQueueRedisConnection, newWorkerRedisConnection } from '../redis';

export enum QueueNames {
  datasetSync = 'datasetSync',
  evaluation = 'evaluation',
  s3FileDelete = 's3FileDelete',
  datasetDelete = 'datasetDelete',
  websiteSync = 'websiteSync'
}

const defaultWorkerOpts: Omit<ConnectionOptions, 'connection'> = {
  removeOnComplete: {
    age: 3600,  // 1小时后删除已完成任务
    count: 100   // 保留最近100个任务
  },
  removeOnFail: {
    age: 86400   // 24小时后删除失败任务
  }
};

export const getQueue = <T>(queueName: QueueNames): Queue<T> => {
  return new Queue(queueName, {
    connection: newQueueRedisConnection()
  });
};

export const getWorker = <T>(
  queueName: QueueNames,
  processor: (job: Job<T>) => Promise<any>,
  opts?: WorkerOptions
): Worker<T> => {
  return new Worker(queueName, processor, {
    connection: newWorkerRedisConnection(),
    ...defaultWorkerOpts,
    ...opts
  });
};
```

## 五、使用场景

### 5.1 MongoDB 使用场景

| 集合 | 用途 | 数据量级 |
|------|------|---------|
| users, teams | 用户和团队管理 | 千-万级 |
| apps | 应用配置 | 千-万级 |
| datasets | 知识库元数据 | 千-万级 |
| chat_histories | 对话历史 | 百万-千万级 |
| usage_logs | 使用日志 | 千万-亿级 |

### 5.2 Redis 使用场景

| 键前缀 | 用途 | TTL |
|--------|------|-----|
| `cache:` | 通用缓存 | 可变 |
| `system:cache:` | 系统缓存和版本控制 | 永久 |
| `frequency:` | 频率限制 | 按策略 |
| `session:` | 会话管理 | 24小时 |
| `lock:` | 分布式锁 | 短期 |

## 六、性能优化

### 6.1 MongoDB 优化

1. **索引优化**
   ```typescript
   // 复合索引
   schema.index({ teamId: 1, createdAt: -1 });
   
   // 唯一索引
   schema.index({ email: 1 }, { unique: true });
   ```

2. **连接池配置**
   ```bash
   MONGODB_URI=mongodb://host:27017/db?maxPoolSize=100
   ```

3. **查询优化**
   - 使用 `.lean()` 返回普通对象
   - 使用 `.select()` 限制字段
   - 分页查询避免 skip

### 6.2 Redis 优化

1. **连接复用**
   - 使用全局连接池
   - 队列使用独立连接

2. **键设计**
   - 使用前缀区分业务
   - 合理设置 TTL

3. **批量操作**
   - 使用 `pipeline` 或 `multi`
   - 减少网络往返

## 七、监控与维护

### 7.1 健康检查

```typescript
// MongoDB 健康检查
export const checkMongoHealth = async (): Promise<boolean> => {
  try {
    await connectionMongo.connection.db.admin().ping();
    return true;
  } catch (error) {
    console.error('MongoDB health check failed:', error);
    return false;
  }
};

// Redis 健康检查
export const checkRedisHealth = async (): Promise<boolean> => {
  try {
    const redis = getGlobalRedisConnection();
    await redis.ping();
    return true;
  } catch (error) {
    console.error('Redis health check failed:', error);
    return false;
  }
};
```

### 7.2 备份策略

**MongoDB**:
```bash
# 定时备份
mongodump --uri="$MONGODB_URI" --out=/backup/$(date +%Y%m%d)

# 增量备份（使用 oplog）
mongodump --uri="$MONGODB_URI" --oplog
```

**Redis**:
```bash
# RDB 快照
SAVE

# AOF 持久化
CONFIG SET appendonly yes
```

## 八、最佳实践

1. **数据库分离**
   - 主数据和日志使用不同的 MongoDB 实例
   - 提高查询性能和隔离故障

2. **缓存策略**
   - 热点数据缓存到 Redis
   - 设置合理的 TTL
   - 使用版本键实现缓存失效

3. **连接管理**
   - 复用数据库连接
   - 合理配置连接池大小
   - 监控连接数

4. **队列管理**
   - 使用 BullMQ 处理异步任务
   - 设置合理的并发数
   - 配置任务重试策略

5. **数据归档**
   - 定期归档历史日志
   - 删除过期数据
   - 使用 TTL 索引自动清理

## 九、相关文件清单

### MongoDB
- `packages/service/common/mongo/index.ts` - 连接管理
- `packages/service/common/mongo/type.d.ts` - 类型定义

### Redis
- `packages/service/common/redis/index.ts` - 连接管理
- `packages/service/common/redis/cache.ts` - 缓存接口
- `packages/service/common/redis/type.d.ts` - 类型定义

### 队列
- `packages/service/common/bullmq/index.ts` - BullMQ 封装

### 缓存
- `packages/service/common/cache/index.ts` - 系统缓存
- `packages/service/common/cache/init.ts` - 缓存初始化

### API
- `packages/service/common/api/frequencyLimit.ts` - 频率限制
