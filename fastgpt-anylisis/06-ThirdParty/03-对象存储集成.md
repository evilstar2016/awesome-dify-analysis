# 对象存储（S3）集成

FastGPT 使用 S3 兼容对象存储服务来管理文件、图片、头像等资源。

## 一、支持的存储服务

| 存储服务 | 状态 | 说明 |
|---------|------|------|
| **MinIO** | ✅ 默认推荐 | 开源 S3 兼容存储，可自部署 |
| **AWS S3** | ✅ 支持 | 亚马逊云对象存储 |
| **阿里云 OSS** | ✅ 支持 | 通过 S3 兼容模式 |
| **腾讯云 COS** | ✅ 支持 | 通过 S3 兼容模式 |
| **其他 S3 兼容存储** | ✅ 支持 | 任何支持 S3 API 的存储 |

## 二、环境配置

### 2.1 环境变量

```bash
# S3 配置
S3_ENDPOINT=localhost                # S3 端点地址
S3_PORT=9000                         # S3 端口（默认 9000）
S3_ACCESS_KEY=minioadmin             # 访问密钥
S3_SECRET_KEY=minioadmin             # 密钥
S3_EXTERNAL_BASE_URL=                # 外部访问 URL（可选）
S3_PATH_STYLE=true                   # 路径风格（true: path-style, false: virtual-hosted-style）

# 代理配置（可选）
HTTP_PROXY=http://proxy:8080         # HTTP 代理
HTTPS_PROXY=https://proxy:8080       # HTTPS 代理
```

### 2.2 配置示例

#### MinIO（默认配置）
```bash
S3_ENDPOINT=minio
S3_PORT=9000
S3_ACCESS_KEY=minioadmin
S3_SECRET_KEY=minioadmin
S3_PATH_STYLE=true
```

#### AWS S3
```bash
S3_ENDPOINT=s3.amazonaws.com
S3_PORT=443
S3_ACCESS_KEY=AKIAXXXXXXXXXXXXXXXX
S3_SECRET_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
S3_PATH_STYLE=false
```

#### 阿里云 OSS（S3 兼容）
```bash
S3_ENDPOINT=oss-cn-beijing.aliyuncs.com
S3_PORT=443
S3_ACCESS_KEY=LTAI5tXXXXXXXXXXXXXX
S3_SECRET_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
S3_PATH_STYLE=false
```

## 三、核心架构

### 3.1 S3 客户端封装（`packages/service/common/s3/constants.ts`）

```typescript
import { HttpProxyAgent } from 'http-proxy-agent';
import { HttpsProxyAgent } from 'https-proxy-agent';
import type { ClientOptions } from 'minio';

// MIME 类型映射
export const Mimes = {
  '.gif': 'image/gif',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.webp': 'image/webp',
  '.svg': 'image/svg+xml',
  '.pdf': 'application/pdf',
  '.txt': 'text/plain',
  '.md': 'text/markdown',
  '.html': 'text/html',
  '.json': 'application/json',
  '.csv': 'text/csv',
  '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
};

// S3 配置选项
export const defaultS3Options: Partial<ClientOptions> = {
  endPoint: process.env.S3_ENDPOINT || 'localhost',
  externalBaseURL: process.env.S3_EXTERNAL_BASE_URL,
  accessKey: process.env.S3_ACCESS_KEY || 'minioadmin',
  secretKey: process.env.S3_SECRET_KEY || 'minioadmin',
  port: process.env.S3_PORT ? parseInt(process.env.S3_PORT) : 9000,
  pathStyle: process.env.S3_PATH_STYLE === 'false' ? false : true,
  
  // 代理支持
  transportAgent: process.env.HTTP_PROXY
    ? new HttpProxyAgent(process.env.HTTP_PROXY)
    : process.env.HTTPS_PROXY
    ? new HttpsProxyAgent(process.env.HTTPS_PROXY)
    : undefined,
  
  useSSL: process.env.S3_USE_SSL !== 'false'
};
```

### 3.2 Bucket 管理

#### Bucket 类型

```typescript
// packages/service/common/s3/type.ts
export enum S3Buckets {
  public = 'fastgpt-public',    // 公开读取的资源
  private = 'fastgpt-private'   // 需要授权访问的资源
}

declare global {
  var s3BucketMap: {
    [key: string]: S3BaseBucket;
  };
}
```

#### Bucket 初始化（`packages/service/common/s3/index.ts`）

```typescript
import { S3PublicBucket } from './buckets/public';
import { S3PrivateBucket } from './buckets/private';

export const initS3 = () => {
  const publicBucket = new S3PublicBucket();
  const privateBucket = new S3PrivateBucket();
  
  global.s3BucketMap = {
    [publicBucket.name]: publicBucket,
    [privateBucket.name]: privateBucket
  };
};
```

### 3.3 基础 Bucket 类（`packages/service/common/s3/buckets/base.ts`）

```typescript
import { Client, type RemoveOptions, type CopyConditions, S3Error } from 'minio';

export class S3BaseBucket {
  private readonly client: Client;
  public readonly name: string;
  
  constructor(
    private readonly bucketName: string,
    public options: Partial<S3OptionsType> = defaultS3Options
  ) {
    this.name = bucketName;
    this.client = new Client({
      endPoint: options.endPoint!,
      port: options.port,
      useSSL: options.useSSL,
      accessKey: options.accessKey!,
      secretKey: options.secretKey!,
      pathStyle: options.pathStyle,
      transportAgent: options.transportAgent
    });
  }
  
  // 初始化 Bucket
  async init(): Promise<void> {
    const exists = await this.client.bucketExists(this.bucketName);
    if (!exists) {
      await this.client.makeBucket(this.bucketName);
      console.log(`Created S3 bucket: ${this.bucketName}`);
    }
  }
  
  // 上传文件
  async putObject(
    key: string,
    data: Buffer | Stream,
    size?: number,
    metadata?: Record<string, string>
  ): Promise<void> {
    await this.client.putObject(
      this.bucketName,
      key,
      data,
      size,
      metadata
    );
  }
  
  // 获取文件
  async getObject(key: string): Promise<Stream> {
    return await this.client.getObject(this.bucketName, key);
  }
  
  // 删除文件
  async delete(key: string): Promise<void> {
    try {
      await this.client.removeObject(this.bucketName, key);
    } catch (error) {
      if (error instanceof S3Error && error.code === 'NoSuchKey') {
        // 文件不存在，忽略错误
        return;
      }
      throw error;
    }
  }
  
  // 批量删除
  async deleteMany(keys: string[]): Promise<void> {
    await this.client.removeObjects(this.bucketName, keys);
  }
  
  // 复制文件
  async copy(
    from: string,
    to: string,
    options?: {
      copyConditions?: CopyConditions;
      temporary?: boolean;
    }
  ): Promise<void> {
    if (options?.temporary) {
      // 临时文件，24 小时后过期
      await MongoS3TTL.create({
        minioKey: to,
        bucketName: this.name,
        expiredTime: addHours(new Date(), 24)
      });
    }
    
    return this.client.copyObject(
      this.bucketName,
      to,
      `${this.bucketName}/${from}`,
      options?.copyConditions
    );
  }
  
  // 获取预签名 URL（用于前端直传）
  async presignedPutObject(
    key: string,
    expiry: number = 3600
  ): Promise<string> {
    return await this.client.presignedPutObject(
      this.bucketName,
      key,
      expiry
    );
  }
  
  // 获取预签名下载 URL
  async presignedGetObject(
    key: string,
    expiry: number = 3600
  ): Promise<string> {
    return await this.client.presignedGetObject(
      this.bucketName,
      key,
      expiry
    );
  }
}
```

### 3.4 Public Bucket（`packages/service/common/s3/buckets/public.ts`）

```typescript
export class S3PublicBucket extends S3BaseBucket {
  constructor() {
    super(S3Buckets.public);
  }
  
  async init(): Promise<void> {
    await super.init();
    
    // 设置公开读取策略
    const policy = JSON.stringify({
      Version: '2012-10-17',
      Statement: [
        {
          Effect: 'Allow',
          Principal: '*',
          Action: 's3:GetObject',
          Resource: `arn:aws:s3:::${this.name}/*`
        }
      ]
    });
    
    try {
      await this.client.setBucketPolicy(this.name, policy);
    } catch (error) {
      console.error('Failed to set public bucket policy:', error);
    }
  }
  
  // 获取公开 URL
  getPublicUrl(key: string): string {
    const baseUrl = this.options.externalBaseURL || 
      `${this.options.useSSL ? 'https' : 'http'}://${this.options.endPoint}:${this.options.port}`;
    
    if (this.options.pathStyle) {
      return `${baseUrl}/${this.name}/${key}`;
    } else {
      return `${baseUrl.replace('://', `://${this.name}.`)}/${key}`;
    }
  }
}
```

## 四、文件 TTL 管理

### 4.1 TTL Schema（`packages/service/common/s3/schema.ts`）

```typescript
import { Schema, getMongoModel } from '../mongo';
import { type S3TtlSchemaType } from '@fastgpt/global/common/file/s3TTL/type';

const collectionName = 's3_ttls';

const S3TTLSchema = new Schema({
  bucketName: {
    type: String,
    required: true
  },
  minioKey: {
    type: String,
    required: true
  },
  expiredTime: {
    type: Date,
    required: true
  }
});

// 索引
S3TTLSchema.index({ expiredTime: 1 });
S3TTLSchema.index({ bucketName: 1, minioKey: 1 });

export const MongoS3TTL = getMongoModel<S3TtlSchemaType>(collectionName, S3TTLSchema);
```

### 4.2 清理过期文件（`packages/service/common/s3/controller.ts`）

```typescript
export async function clearExpiredMinioFiles() {
  try {
    // 查找过期文件
    const expiredFiles = await MongoS3TTL.find({
      expiredTime: { $lte: new Date() }
    }).lean();
    
    if (expiredFiles.length === 0) {
      console.log('No expired minio files to clean');
      return;
    }
    
    console.log(`Found ${expiredFiles.length} expired minio files to clean`);
    
    let success = 0;
    let fail = 0;
    
    for (const file of expiredFiles) {
      try {
        const bucket = global.s3BucketMap[file.bucketName];
        
        if (bucket) {
          // 删除文件
          await bucket.delete(file.minioKey);
          
          // 同时删除解析后的文件（如果存在）
          if (!file.minioKey.includes('-parsed/')) {
            try {
              const dir = path.dirname(file.minioKey);
              const basename = path.basename(file.minioKey);
              const ext = path.extname(basename);
              
              if (ext) {
                const nameWithoutExt = path.basename(basename, ext);
                const parsedPrefix = `${dir}/${nameWithoutExt}-parsed`;
                
                // 添加异步删除任务
                await addS3DelJob({
                  prefix: parsedPrefix,
                  bucketName: file.bucketName
                });
              }
            } catch (error) {
              console.debug(`Failed to schedule parsed images deletion for ${file.minioKey}`);
            }
          }
          
          // 从 TTL 记录中删除
          await MongoS3TTL.deleteOne({ _id: file._id });
          success++;
          
          console.log(`Deleted expired minio file: ${file.minioKey} from bucket: ${file.bucketName}`);
        } else {
          console.warn(`Bucket not found: ${file.bucketName}`);
        }
      } catch (error) {
        fail++;
        console.error(`Failed to delete minio file: ${file.minioKey}`, error);
      }
    }
    
    console.log(`Minio TTL cleanup completed. Success: ${success}, Failed: ${fail}`);
  } catch (error) {
    console.error('Minio TTL cleanup error:', error);
  }
}
```

## 五、异步删除队列

### 5.1 队列定义（`packages/service/common/bullmq/index.ts`）

```typescript
export enum QueueNames {
  s3FileDelete = 's3FileDelete',
  // ... 其他队列
}
```

### 5.2 删除队列实现（`packages/service/common/s3/mq.ts`）

```typescript
import { getQueue, getWorker } from '../bullmq';
import { QueueNames } from '../bullmq/constants';
import pLimit from 'p-limit';

export type S3MQJobData = {
  bucketName: string;
  key?: string;        // 单个文件
  keys?: string[];     // 批量文件
  prefix?: string;     // 前缀（批量删除）
};

// 添加删除任务
export const addS3DelJob = async (data: S3MQJobData): Promise<void> => {
  const queue = getQueue<S3MQJobData>(QueueNames.s3FileDelete);
  
  await queue.add(
    'delete-s3-files',
    { ...data },
    {
      attempts: 3,
      removeOnFail: false,
      removeOnComplete: true,
      backoff: {
        type: 'exponential',
        delay: 5000
      }
    }
  );
};

// 启动删除 Worker
export const startS3DelWorker = async () => {
  return getWorker<S3MQJobData>(
    QueueNames.s3FileDelete,
    async (job) => {
      const { prefix, bucketName, key, keys } = job.data;
      const limit = pLimit(10);
      const bucket = s3BucketMap[bucketName];
      
      if (!bucket) {
        return Promise.reject(`Bucket not found: ${bucketName}`);
      }
      
      if (key) {
        // 删除单个文件
        await bucket.delete(key);
      } else if (keys) {
        // 批量删除
        await bucket.deleteMany(keys);
      } else if (prefix) {
        // 按前缀删除
        const objectsList = await bucket.listObjects(prefix);
        const deletePromises = objectsList.map((obj) =>
          limit(() => bucket.delete(obj.name))
        );
        await Promise.all(deletePromises);
      }
    },
    {
      concurrency: 5,
      removeOnComplete: { age: 3600 },
      removeOnFail: { age: 86400 }
    }
  );
};
```

## 六、S3 数据源

### 6.1 头像管理（`packages/service/common/s3/sources/avatar.ts`）

```typescript
export class S3AvatarSource {
  private bucket: S3PublicBucket;
  private prefix = 'avatar/';
  
  constructor() {
    this.bucket = global.s3BucketMap[S3Buckets.public];
  }
  
  // 上传头像
  async uploadAvatar(
    buffer: Buffer,
    fileName: string,
    metadata?: Record<string, string>
  ): Promise<string> {
    const key = `${this.prefix}${getNanoid()}${path.extname(fileName)}`;
    
    await this.bucket.putObject(key, buffer, buffer.length, {
      'Content-Type': getMimeType(fileName),
      ...metadata
    });
    
    return this.bucket.getPublicUrl(key);
  }
  
  // 删除头像
  async deleteAvatar(avatar: string, session?: ClientSession): Promise<void> {
    const key = avatar.slice(this.prefix.length);
    await MongoS3TTL.deleteOne({ minioKey: key, bucketName: this.bucket.name }, session);
    await this.bucket.delete(key);
  }
  
  // 移除头像 TTL
  async removeAvatarTTL(avatar: string, session?: ClientSession): Promise<void> {
    const key = avatar.slice(this.prefix.length);
    await MongoS3TTL.deleteOne({ minioKey: key, bucketName: this.bucket.name }, session);
  }
  
  // 刷新头像（更新时）
  async refreshAvatar(
    newAvatar?: string,
    oldAvatar?: string,
    session?: ClientSession
  ) {
    if (!newAvatar || newAvatar === oldAvatar) return;
    
    // 移除新头像的 TTL
    if (isS3ObjectKey(newAvatar)) {
      await this.removeAvatarTTL(newAvatar, session);
    }
    
    // 删除旧头像
    if (oldAvatar && isS3ObjectKey(oldAvatar) && oldAvatar !== newAvatar) {
      await this.deleteAvatar(oldAvatar, session);
    }
  }
}

export const getS3AvatarSource = () => new S3AvatarSource();
```

### 6.2 数据集文件管理（`packages/service/common/s3/sources/dataset/index.ts`）

```typescript
export class S3DatasetSource {
  public bucket: S3PrivateBucket;
  
  constructor() {
    this.bucket = global.s3BucketMap[S3Buckets.private];
  }
  
  // 上传数据集文件
  async uploadDatasetFile({
    teamId,
    datasetId,
    fileName,
    buffer
  }: {
    teamId: string;
    datasetId: string;
    fileName: string;
    buffer: Buffer;
  }): Promise<string> {
    const key = `dataset/${teamId}/${datasetId}/${getNanoid()}${path.extname(fileName)}`;
    
    await this.bucket.putObject(key, buffer, buffer.length, {
      'Content-Type': getMimeType(fileName)
    });
    
    return key;
  }
  
  // 获取文件
  async getDatasetFile(fileId: string): Promise<Buffer> {
    const stream = await this.bucket.getObject(fileId);
    return await streamToBuffer(stream);
  }
  
  // 删除数据集文件
  async deleteDatasetFile(fileId: string): Promise<void> {
    const { fileKey, fileParsedPrefix } = getFileS3Key.s3Key(fileId);
    
    // 删除原文件
    await this.bucket.delete(fileKey);
    
    // 删除解析后的文件
    await addS3DelJob({
      prefix: fileParsedPrefix,
      bucketName: this.bucket.name
    });
  }
  
  // 上传临时文件（3小时后自动删除）
  async uploadTempFile(
    buffer: Buffer,
    fileName: string
  ): Promise<string> {
    const key = `temp/${getNanoid()}${path.extname(fileName)}`;
    
    await MongoS3TTL.create({
      minioKey: key,
      bucketName: this.bucket.name,
      expiredTime: addHours(new Date(), 3)
    });
    
    await this.bucket.putObject(key, buffer, buffer.length);
    
    return key;
  }
}

export const getS3DatasetSource = () => new S3DatasetSource();
```

## 七、工具函数（`packages/service/common/s3/utils.ts`）

```typescript
// 检查是否是 S3 对象 Key
export const isS3ObjectKey = (key: string): boolean => {
  return key.startsWith('avatar/') || 
         key.startsWith('dataset/') || 
         key.startsWith('temp/');
};

// 删除 S3 TTL 记录
export const deleteS3TTLRecord = async (
  key: string | string[],
  bucketName: keyof typeof S3Buckets,
  session?: ClientSession
): Promise<void> => {
  if (Array.isArray(key)) {
    return MongoS3TTL.deleteMany(
      {
        minioKey: { $in: key },
        bucketName: S3Buckets[bucketName]
      },
      { session }
    );
  } else {
    return MongoS3TTL.deleteOne(
      {
        minioKey: key,
        bucketName: S3Buckets[bucketName]
      },
      { session }
    );
  }
};

// 上传图片到 S3
export const uploadImage2S3Bucket = async ({
  buffer,
  fileName,
  metadata
}: {
  buffer: Buffer;
  fileName: string;
  metadata?: Record<string, string>;
}): Promise<string> => {
  const bucket = global.s3BucketMap[S3Buckets.public];
  const uploadKey = `images/${getNanoid()}${path.extname(fileName)}`;
  
  await bucket.putObject(uploadKey, buffer, buffer.length, {
    'Content-Type': getMimeType(fileName),
    ...metadata
  });
  
  return bucket.getPublicUrl(uploadKey);
};

// 获取文件 S3 Key
export const getFileS3Key = {
  s3Key: (key: string) => {
    const prefix = `${path.dirname(key)}/${path.basename(key, path.extname(key))}-parsed`;
    return {
      fileKey: key,
      fileParsedPrefix: prefix
    };
  }
};
```

## 八、图片处理集成（`packages/service/common/file/image/controller.ts`）

```typescript
import { S3Sources } from '../../s3/type';
import { getS3AvatarSource } from '../../s3/sources/avatar';
import { isS3ObjectKey } from '../../s3/utils';

// 压缩并上传图片
export const compressAndUploadImage = async ({
  buffer,
  fileName,
  maxSize = 1024 * 1024 * 2  // 2MB
}: {
  buffer: Buffer;
  fileName: string;
  maxSize?: number;
}): Promise<string> => {
  // 压缩图片
  let compressed = buffer;
  if (buffer.length > maxSize) {
    compressed = await compressImage(buffer, maxSize);
  }
  
  // 上传到 S3
  const avatarSource = getS3AvatarSource();
  return await avatarSource.uploadAvatar(compressed, fileName);
};

// 从 URL 或 Base64 获取并上传图片
export const getImageFromUrlOrBase64 = async (
  imgStr: string
): Promise<string> => {
  // 如果已经是 S3 Key，直接返回
  if (isS3ObjectKey(imgStr)) {
    return imgStr;
  }
  
  let buffer: Buffer;
  
  // Base64 格式
  if (imgStr.startsWith('data:image/')) {
    const base64Data = imgStr.split(',')[1];
    buffer = Buffer.from(base64Data, 'base64');
  }
  // URL 格式
  else if (imgStr.startsWith('http')) {
    const response = await axios.get(imgStr, { responseType: 'arraybuffer' });
    buffer = Buffer.from(response.data);
  } else {
    throw new Error('Invalid image format');
  }
  
  // 上传到 S3
  return await uploadImage2S3Bucket({
    buffer,
    fileName: 'image.png'
  });
};
```

## 九、定时任务

### 9.1 清理过期文件定时任务

```typescript
// 每小时执行一次
schedule.scheduleJob('0 * * * *', async () => {
  await clearExpiredMinioFiles();
});
```

## 十、监控与统计

### 10.1 存储使用统计

```typescript
// 获取团队存储使用量
export const getTeamStorageUsage = async (teamId: string): Promise<number> => {
  const bucket = global.s3BucketMap[S3Buckets.private];
  const prefix = `dataset/${teamId}/`;
  
  let totalSize = 0;
  const stream = bucket.listObjects(prefix, true);
  
  for await (const obj of stream) {
    totalSize += obj.size;
  }
  
  return totalSize;
};
```

## 十一、最佳实践

1. **文件分类存储**
   - Public Bucket: 头像、公开图片
   - Private Bucket: 数据集文件、用户文档

2. **TTL 管理**
   - 临时文件: 3 小时
   - 临时副本: 24 小时
   - 定期清理过期文件

3. **性能优化**
   - 使用预签名 URL 实现前端直传
   - 批量删除使用异步队列
   - 图片压缩后再上传

4. **安全配置**
   - Private Bucket 不设置公开访问
   - 使用预签名 URL 控制访问时效
   - API Key 使用环境变量管理

5. **高可用部署**
   - MinIO 集群模式
   - 配置备份策略
   - 监控存储使用量

## 十二、相关文件清单

### 核心实现
- `packages/service/common/s3/index.ts` - S3 初始化
- `packages/service/common/s3/constants.ts` - 配置常量
- `packages/service/common/s3/type.ts` - 类型定义
- `packages/service/common/s3/utils.ts` - 工具函数

### Bucket 管理
- `packages/service/common/s3/buckets/base.ts` - 基础 Bucket 类
- `packages/service/common/s3/buckets/public.ts` - 公开 Bucket
- `packages/service/common/s3/buckets/private.ts` - 私有 Bucket

### 数据源
- `packages/service/common/s3/sources/avatar.ts` - 头像管理
- `packages/service/common/s3/sources/dataset/index.ts` - 数据集文件管理

### TTL 管理
- `packages/service/common/s3/schema.ts` - TTL Schema
- `packages/service/common/s3/controller.ts` - 过期文件清理
- `packages/service/common/s3/mq.ts` - 异步删除队列

### 图片处理
- `packages/service/common/file/image/controller.ts` - 图片上传和压缩
