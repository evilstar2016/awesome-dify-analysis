@startuml 工作流执行核心时序图

!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

actor "用户" as User
participant "API路由\n(/api/v*/chat/completions)" as API
participant "dispatchWorkFlow" as Dispatcher
participant "runWorkflow" as Runner
participant "WorkflowQueue" as Queue
participant "NodeHandlers\n(callbackMap)" as Handlers
participant "流式响应\n(SSE)" as SSE
database "MongoDB" as DB

== 1. 工作流初始化 ==

User -> API: POST /api/v1/chat/completions\n{appId, messages, variables}
activate API

API -> API: 权限验证 (authApp)
API -> API: 余额检查 (checkTeamAIPoints)
API -> DB: 获取应用配置\n(getAppLatestVersion)
activate DB
DB --> API: {nodes, edges, chatConfig}
deactivate DB

API -> API: 获取历史记录\n(getChatItems)
API -> API: 转换为运行时节点\n(storeNodes2RuntimeNodes)

note right of API
  运行时转换:
  1. StoreNode → RuntimeNode
  2. StoreEdge → RuntimeEdge
  3. 标记入口节点 (isEntry)
  4. 设置边状态 (waiting)
end note

API -> SSE: 设置SSE响应头
activate SSE
note right of SSE
  Content-Type: text/event-stream
  Cache-Control: no-cache
  Connection: keep-alive
end note

== 2. 工作流调度 ==

API -> Dispatcher: dispatchWorkFlow(props)
activate Dispatcher

Dispatcher -> Dispatcher: 准备系统变量\n(getSystemVariables)
note right of Dispatcher
  系统变量:
  - cTime: 当前时间
  - userId, chatId, appId
  - timezone: 时区
  - histories: 历史记录
end note

Dispatcher -> Runner: runWorkflow(data)
activate Runner

Runner -> Runner: 检查执行深度\n(workflowDispatchDeep)
note right of Runner
  防止无限递归
  最大深度: 20
end note

Runner -> Runner: 重写运行时工作流\n(rewriteRuntimeWorkFlow)

== 3. 队列初始化 ==

Runner -> Queue: new WorkflowQueue({resolve})
activate Queue

Queue -> Queue: 初始化队列属性
note right of Queue
  - activeRunQueue: Set<nodeId>
  - skipNodeQueue: Map<nodeId, {...}>
  - runningNodeCount: 0
  - maxConcurrency: 10
  - runtimeNodesMap: Map
end note

Runner -> Runner: 获取入口节点\n(filter isEntry)

loop 每个入口节点
  Runner -> Queue: addActiveNode(entryNodeId)
  Queue -> Queue: activeRunQueue.add(nodeId)
end

Runner -> Queue: processActiveNode()

== 4. 节点执行循环 ==

loop 直到队列为空

  Queue -> Queue: 检查完成条件
  alt 队列为空 且 无运行节点
    Queue -> Queue: resolve(this)
    note right of Queue: 工作流执行完成
  else 达到并发限制
    Queue -> Queue: 等待节点完成
  else 有待执行节点
    Queue -> Queue: 从队列取出节点
    Queue -> Queue: runningNodeCount++
    
    Queue -> Queue: checkNodeCanRun(node)
    
    == 4.1 检查节点状态 ==
    
    Queue -> Queue: 检查余额\n(checkTeamBlance)
    Queue -> Queue: 让出CPU\n(surrenderProcess)
    Queue -> Queue: 获取节点运行状态\n(checkNodeRunStatus)
    
    note right of Queue
      节点状态判断:
      - isEntry → 'run'
      - 所有入边 active → 'run'
      - 所有入边 skipped → 'skip'
      - 其他 → 'wait'
    end note
    
    alt 状态 = run
      Queue -> Queue: nodeRunWithActive(node)
      
      == 4.2 执行节点 ==
      
      Queue -> Queue: getNodeRunParams(node)
      note right of Queue
        参数准备:
        1. 替换变量引用 {{var}}
        2. 替换节点输出 {{$nodeId.key$}}
        3. 获取引用变量值
        4. 类型转换 (valueTypeFormat)
      end note
      
      Queue -> SSE: 发送节点状态\nevent: flowNodeStatus
      SSE --> User: {status: 'running', name}
      
      Queue -> Handlers: callbackMap[nodeType](props)
      activate Handlers
      
      alt AI 对话节点
        Handlers -> Handlers: dispatchChatCompletion
        Handlers -> Handlers: 构建消息列表
        Handlers -> Handlers: 调用 LLM API
        
        loop 流式响应
          Handlers -> SSE: event: answer\ndata: {text: chunk}
          SSE --> User: 实时显示回答
        end
        
        Handlers --> Queue: {assistantResponses, usage}
        
      else 知识库检索节点
        Handlers -> Handlers: dispatchDatasetSearch
        Handlers -> DB: 向量检索
        activate DB
        DB --> Handlers: searchResults
        deactivate DB
        Handlers -> Handlers: 重排序 (可选)
        Handlers --> Queue: {quoteQA, searchRes}
        
      else HTTP 请求节点
        Handlers -> Handlers: dispatchHttp468
        Handlers -> Handlers: 变量替换
        Handlers -> Handlers: 构建请求
        Handlers -> "外部API": HTTP Request
        activate "外部API"
        "外部API" --> Handlers: Response
        deactivate "外部API"
        Handlers -> Handlers: JSONPath 提取结果
        Handlers --> Queue: {httpResult, outputs}
        
      else 条件分支节点
        Handlers -> Handlers: dispatchIfElse
        Handlers -> Handlers: 计算条件表达式
        Handlers --> Queue: {skipHandleId: [...]}
        
      else 其他节点类型
        Handlers -> Handlers: 执行对应处理器
        Handlers --> Queue: result
      end
      
      deactivate Handlers
      
      Queue -> Queue: 格式化响应数据
      Queue -> SSE: event: flowNodeResponse
      SSE --> User: {nodeId, moduleName, result}
      
      Queue -> Queue: 更新节点输出值
      Queue -> Queue: 更新变量 (newVariables)
      
      Queue -> DB: 记录资源消耗\n(pushChatItemUsage)
      activate DB
      DB --> Queue: OK
      deactivate DB
      
      Queue -> Queue: pushStore(result)
      note right of Queue
        存储:
        - chatResponses
        - chatAssistantResponse
        - chatNodeUsages
        - toolRunResponse
        - system_memories
      end note
      
    else 状态 = skip
      Queue -> Queue: nodeRunWithSkip(node)
      Queue -> Queue: 标记所有出边为 skipped
      
    else 状态 = wait
      Queue -> Queue: 跳过，等待前置节点
    end
    
    == 4.3 处理后续节点 ==
    
    Queue -> Queue: nodeOutput(node, result)
    
    Queue -> Queue: 获取 skipHandleId
    Queue -> Queue: 过滤目标边\n(filterWorkflowEdges)
    
    loop 每条出边
      Queue -> Queue: 更新边状态
      note right of Queue
        if sourceHandle in skipHandleId:
          edge.status = 'skipped'
        else:
          edge.status = 'active'
      end note
    end
    
    Queue -> Queue: 获取下一批节点
    note right of Queue
      nextStepActiveNodes: 
        所有入边包含 active 的节点
      nextStepSkipNodes:
        所有入边都是 skipped 的节点
    end note
    
    alt 遇到交互节点
      Queue -> Queue: 设置 nodeInteractiveResponse
      Queue -> SSE: event: interactive
      SSE --> User: {type, params, memoryEdges, ...}
      note over Queue
        暂停执行
        等待用户交互
      end note
      
    else Debug 模式
      Queue -> Queue: debugNextStepRunNodes.push(...)
      note right of Queue: 等待下一步操作
      
    else 正常模式
      loop 每个激活节点
        Queue -> Queue: addActiveNode(nodeId)
      end
      
      loop 每个跳过节点
        Queue -> Queue: addSkipNode(node, skippedList)
      end
    end
    
    Queue -> Queue: runningNodeCount--
    Queue -> Queue: processActiveNode()
    note right of Queue: 递归处理下一个节点
    
  end
  
end

== 5. 完成与返回 ==

Queue --> Runner: WorkflowQueue 实例
deactivate Queue

Runner -> Runner: 处理交互结果\n(handleInteractiveResult)
Runner -> Runner: 合并助手响应\n(mergeAssistantResponseAnswerText)
Runner -> Runner: 计算执行时长

Runner -> SSE: event: workflowDuration
SSE --> User: {durationSeconds}

Runner --> Dispatcher: {flowResponses, assistantResponses, ...}
deactivate Runner

Dispatcher --> API: {flowResponses, flowUsages, ...}
deactivate Dispatcher

== 6. 保存记录 ==

API -> API: 构建保存参数
API -> DB: saveChat({chatId, userContent, aiContent, ...})
activate DB
DB -> DB: 保存对话记录
DB -> DB: 保存聊天项
DB -> DB: 更新使用统计
DB --> API: OK
deactivate DB

API -> SSE: event: answer\ndata: [DONE]
SSE --> User: 流结束
deactivate SSE

API --> User: 200 OK\n{choices, responseData, usage}
deactivate API

@enduml
