@startuml 交互式工作流时序图

!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

actor "用户" as User
participant "前端应用" as Frontend
participant "API路由" as API
participant "WorkflowQueue" as Queue
participant "交互节点\n(formInput/userSelect)" as Interactive
participant "SSE Stream" as SSE
database "MongoDB" as DB

== 第一阶段: 执行到交互节点 ==

User -> Frontend: 发起对话请求
Frontend -> API: POST /api/v1/chat/completions\n{appId, chatId, messages}
activate API

API -> API: 初始化工作流
API -> Queue: 开始执行
activate Queue

Queue -> Queue: 执行节点 1 → 节点 2 → ...

Queue -> Interactive: 执行交互节点
activate Interactive

Interactive -> Interactive: 构建交互配置
note right of Interactive
  type: 'formInput' 或 'userSelect'
  params: {
    description: '请填写信息',
    formInputs: [
      {label: '姓名', key: 'name', required: true},
      {label: '年龄', key: 'age', type: 'number'},
      ...
    ]
  }
end note

Interactive --> Queue: {interactive: interactiveResponse}
deactivate Interactive

Queue -> Queue: 设置 nodeInteractiveResponse
note right of Queue
  nodeInteractiveResponse = {
    entryNodeIds: ['interactiveNodeId'],
    interactiveResponse: {...}
  }
end note

Queue -> Queue: 暂停执行\n(不继续 processActiveNode)

Queue -> Queue: handleInteractiveResult
activate Queue

Queue -> Queue: 收集当前所有节点输出
note right of Queue
  nodeOutputs: [
    {nodeId: 'node1', key: 'output1', value: '...'},
    {nodeId: 'node2', key: 'output2', value: '...'},
    ...
  ]
end note

Queue -> Queue: 保存跳过队列
note right of Queue
  skipNodeQueue: [
    {id: 'nodeX', skippedNodeIdList: [...]},
    ...
  ]
end note

Queue -> Queue: 标记入口边为 active
note right of Queue
  memoryEdges: [
    {..., status: 'active'},  // 交互节点前的边
    {..., status: 'waiting'}, // 交互节点后的边
    ...
  ]
end note

Queue -> Queue: 构建交互响应
note right of Queue
  WorkflowInteractiveResponseType: {
    type: 'formInput',
    params: {...},
    entryNodeIds: ['interactiveNodeId'],
    memoryEdges: [...],
    nodeOutputs: [...],
    skipNodeQueue: [...],
    usageId: '...'
  }
end note

deactivate Queue

Queue --> API: {workflowInteractiveResponse: {...}}
deactivate Queue

API -> SSE: event: interactive
activate SSE
SSE -> Frontend: data: {interactive: {...}}
Frontend -> Frontend: 显示交互表单/选项

SSE -> SSE: event: answer\ndata: [DONE]
SSE --> Frontend: 流结束
deactivate SSE

API -> DB: 保存中间状态\n(updateInteractiveChat)
activate DB
note right of DB
  保存当前执行状态:
  - chatId
  - nodeOutputs
  - memoryEdges
  - skipNodeQueue
  - usageId
end note
DB --> API: OK
deactivate DB

API --> Frontend: 200 OK\n{interactive: {...}}
deactivate API

== 用户交互阶段 ==

Frontend -> Frontend: 渲染交互界面
alt 表单输入 (formInput)
  Frontend -> User: 显示表单\n(姓名、年龄等字段)
  User -> Frontend: 填写并提交表单
  Frontend -> Frontend: 验证输入\n(必填项、类型等)
  
else 用户选择 (userSelect)
  Frontend -> User: 显示选项列表
  User -> Frontend: 选择一个选项
  
else 支付暂停 (paymentPause)
  Frontend -> User: 提示余额不足
  User -> Frontend: 充值后继续
end

Frontend -> Frontend: 构建续传请求
note right of Frontend
  {
    appId,
    chatId,
    messages: [...],
    variables: {
      ...interactive.nodeOutputs,
      ...userInputValues  // 用户填写的值
    },
    lastInteractive: {
      usageId,
      entryNodeIds,
      memoryEdges,
      skipNodeQueue,
      nodeOutputs
    }
  }
end note

== 第二阶段: 从交互节点继续执行 ==

Frontend -> API: POST /api/v1/chat/completions\n{lastInteractive, userInputValues}
activate API

API -> API: 检测到 lastInteractive
note right of API
  续传模式:
  1. 使用 lastInteractive.usageId
  2. 使用 lastInteractive.memoryEdges
  3. 从 entryNodeIds 继续
end note

API -> DB: 获取历史记录\n(包括上次的 nodeOutputs)
activate DB
DB --> API: histories with interactive value
deactivate DB

API -> API: 合并变量
note right of API
  variables = {
    ...chat.variables,         // 存储的变量
    ...interactive.nodeOutputs, // 节点输出
    ...userInputValues          // 用户输入
  }
end note

API -> API: 转换运行时节点
note right of API
  storeNodes2RuntimeNodes(
    nodes,
    entryNodeIds  // 从交互节点继续
  )
end note

API -> API: 恢复边状态
note right of API
  storeEdges2RuntimeEdges(
    edges,
    interactive
  )
  
  使用 memoryEdges 恢复状态
end note

API -> API: rewriteNodeOutputByHistories
note right of API
  从 interactive.nodeOutputs
  恢复之前节点的输出值
end note

API -> Queue: runWorkflow({...})
activate Queue

Queue -> Queue: new WorkflowQueue({...})
note right of Queue
  初始化队列:
  - 恢复 skipNodeQueue
  - 恢复 memoryEdges
end note

loop 每个 entryNodeId
  Queue -> Queue: addActiveNode(entryNodeId)
end

Queue -> Queue: processActiveNode()

Queue -> Queue: 继续执行后续节点
note right of Queue
  从交互节点后的节点开始:
  节点 N+1 → 节点 N+2 → ...
end note

loop 执行剩余节点
  Queue -> Queue: checkNodeCanRun
  Queue -> Queue: nodeRunWithActive
  Queue -> SSE: 流式返回结果
  activate SSE
  SSE -> Frontend: 实时显示执行过程
  deactivate SSE
end

Queue -> Queue: 所有节点执行完成

Queue --> API: {flowResponses, assistantResponses, ...}
deactivate Queue

API -> DB: 保存最终结果\n(updateInteractiveChat)
activate DB
note right of DB
  更新对话记录:
  - 完整的 AI 响应
  - 所有节点执行结果
  - 最终变量状态
  - 总消耗积分
end note
DB --> API: OK
deactivate DB

API -> SSE: event: answer\ndata: [DONE]
activate SSE
SSE --> Frontend: 流结束
deactivate SSE

API --> Frontend: 200 OK\n{choices, responseData}
deactivate API

Frontend -> User: 显示完整回答

== Debug 模式的交互 ==

note over User, DB
  Debug 模式下的单步执行:
  1. 前端发起 debug 请求
  2. 执行一个节点后暂停
  3. 返回 debugResponse
  4. 前端展示节点状态
  5. 用户点击"下一步"
  6. 发起续传请求（带 memoryEdges、entryNodeIds）
  7. 继续执行下一个节点
  8. 循环直到完成
end note

@enduml
