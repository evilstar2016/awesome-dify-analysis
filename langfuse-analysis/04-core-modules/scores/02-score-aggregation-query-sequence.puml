@startuml Score Aggregation Query Flow


title Score èšåˆæŸ¥è¯¢æµç¨‹ï¼ˆTrace è¯¦æƒ…é¡µï¼‰

actor "ç”¨æˆ·\n(User)" as User
participant "Web\nUI" as WebUI
participant "tRPC\nRouter" as TRPC
participant "Trace\nRepository" as TraceRepo
participant "Score\nRepository" as ScoreRepo
participant "PostgreSQL" as PG
participant "ClickHouse" as CH
participant "Aggregate\nLib" as AggLib

== åŠ è½½ Trace è¯¦æƒ… ==

User -> WebUI: è®¿é—® Trace è¯¦æƒ…é¡µ\n(/traces/:traceId)
activate WebUI

WebUI -> TRPC: traces.byIdWithObservationsAndScores(\n  traceId, projectId\n)
activate TRPC

TRPC -> TRPC: é€šè¿‡ protectedGetTraceProcedure\nä» ctx.trace è·å– trace ä¿¡æ¯

TRPC -> TraceRepo: getObservationsForTrace(\n  traceId, projectId\n)
activate TraceRepo
TraceRepo -> CH: æŸ¥è¯¢ observations\n(WHERE trace_id = ?)
activate CH
return observations åˆ—è¡¨
deactivate TraceRepo

TRPC -> ScoreRepo: getScoresForTraces(\n  projectId, [traceId]\n)
activate ScoreRepo
ScoreRepo -> CH: æŸ¥è¯¢ scores\n(WHERE trace_id = ?)
activate CH

note right of CH
  æŸ¥è¯¢æ¡ä»¶ï¼š
  - project_id = ?
  - trace_id = ?
  ORDER BY timestamp DESC
  
  è¿”å›æ‰€æœ‰ scoresï¼š
  - trace level: observation_id IS NULL
  - observation level: observation_id IS NOT NULL
end note

return scores åˆ—è¡¨
deactivate ScoreRepo

TRPC -> TRPC: éªŒè¯å’Œèšåˆæ•°æ®\nfilterAndValidateDbScoreList()

TRPC --> WebUI: è¿”å›å®Œæ•´ trace\n{trace, observations, scores}
deactivate TRPC

WebUI <-- TRPC: trace æ•°æ®

== å‰ç«¯èšåˆ Scores ==

WebUI -> AggLib: aggregateScores(trace.scores)
activate AggLib

loop éå† scores
  AggLib -> AggLib: è®¡ç®— aggregateKey\n= name-source-dataType
  
  note right of AggLib
    ä¾‹å¦‚ï¼š
    - "accuracy-API-NUMERIC"
    - "quality-ANNOTATION-CATEGORICAL"
    - "is_correct-EVAL-BOOLEAN"
  end note
  
  AggLib -> AggLib: æŒ‰ key åˆ†ç»„ scores
end

note right of AggLib
  åˆ†ç»„ç»“æœç¤ºä¾‹ï¼š
  {
    "accuracy-API-NUMERIC": [
      {id: "s1", value: 0.95, ...},
      {id: "s2", value: 0.87, ...}
    ],
    "quality-ANNOTATION-CATEGORICAL": [
      {id: "s3", stringValue: "Good", value: 4, ...},
      {id: "s4", stringValue: "Excellent", value: 5, ...}
    ]
  }
end note

loop æ¯ä¸ªåˆ†ç»„

  alt NUMERIC ç±»å‹
    AggLib -> AggLib: è®¡ç®—å¹³å‡å€¼
    note right of AggLib
      values = [0.95, 0.87, 0.92]
      average = sum(values) / count
               = 2.74 / 3
               = 0.913
    end note
    
    AggLib -> AggLib: æ„é€  NUMERIC aggregate
    note right of AggLib
      {
        type: "NUMERIC",
        values: [0.95, 0.87, 0.92],
        average: 0.913,
        comment: undefined,  // å¤šä¸ª scores
        id: undefined,
        hasMetadata: undefined
      }
    end note
    
  else CATEGORICAL / BOOLEAN ç±»å‹
    AggLib -> AggLib: resolveAggregateType(\n  dataType\n)
    note right of AggLib
      BOOLEAN è§†ä¸º CATEGORICAL
    end note
    
    AggLib -> AggLib: ç»Ÿè®¡å„ç±»åˆ«æ•°é‡
    note right of AggLib
      values = ["Good", "Excellent", "Good", "Fair"]
      
      valueCounts = [
        { value: "Good", count: 2 },
        { value: "Excellent", count: 1 },
        { value: "Fair", count: 1 }
      ]
    end note
    
    AggLib -> AggLib: æ„é€  CATEGORICAL aggregate
    note right of AggLib
      {
        type: "CATEGORICAL",
        values: ["Good", "Excellent", "Good", "Fair"],
        valueCounts: [
          { value: "Good", count: 2 },
          { value: "Excellent", count: 1 },
          { value: "Fair", count: 1 }
        ],
        comment: undefined,
        id: undefined
      }
    end note
  end
  
  alt å•ä¸ª score
    note right of AggLib
      å¦‚æœåˆ†ç»„åªæœ‰ 1 ä¸ª scoreï¼š
      {
        ...,
        comment: score.comment,
        id: score.id,
        hasMetadata: score.hasMetadata,
        timestamp: score.timestamp
      }
    end note
  end

end

AggLib --> WebUI: è¿”å›èšåˆç»“æœ\n{ [key]: aggregate }
deactivate AggLib

== æ¸²æŸ“ Scores ==

WebUI -> WebUI: æ¸²æŸ“èšåˆ scores

note right of WebUI
  æ˜¾ç¤ºç­–ç•¥ï¼š
  
  1. Trace Level Scores (observation_id IS NULL)
     - æ˜¾ç¤ºåœ¨ Trace Card é¡¶éƒ¨
  
  2. Observation Level Scores (æŒ‰ observation_id åˆ†ç»„)
     - æ˜¾ç¤ºåœ¨å„ Observation Card ä¸­
  
  3. æ¯ä¸ªèšåˆ scoreï¼š
     - NUMERIC: æ˜¾ç¤ºå¹³å‡å€¼ï¼ˆå’ŒèŒƒå›´ï¼‰
     - CATEGORICAL: æ˜¾ç¤ºé¥¼å›¾æˆ–æ¡å½¢å›¾
     - BOOLEAN: æ˜¾ç¤º True/False æ•°é‡
end note

loop æ¯ä¸ª aggregateKey

  WebUI -> AggLib: decomposeAggregateScoreKey(key)
  activate AggLib
  
  note right of AggLib
    è§£æ key è·å–å…ƒä¿¡æ¯ï¼š
    "accuracy-API-NUMERIC"
    â†’ { name: "accuracy", source: "API", dataType: "NUMERIC" }
  end note
  
  return { name, source, dataType }
  
  WebUI -> AggLib: getScoreLabelFromKey(key)
  activate AggLib
  
  note right of AggLib
    ç”Ÿæˆæ˜¾ç¤º labelï¼š
    "accuracy-API-NUMERIC"
    â†’ "ğŸ“Š accuracy (api)"
  end note
  
  return label
  
  WebUI -> WebUI: æ¸²æŸ“ Score Card
  
  alt NUMERIC
    note right of WebUI
      æ˜¾ç¤ºï¼š
      - Label: "ğŸ“Š accuracy (api)"
      - Average: 0.913
      - Range: [0.87 - 0.95]
      - Count: 3 scores
    end note
    
  else CATEGORICAL
    note right of WebUI
      æ˜¾ç¤ºï¼š
      - Label: "ğŸ“Š quality (annotation)"
      - Pie Chart:
        * Good: 50% (2)
        * Excellent: 25% (1)
        * Fair: 25% (1)
      - Total: 4 scores
    end note
    
  else BOOLEAN
    note right of WebUI
      æ˜¾ç¤ºï¼š
      - Label: "âœ“ is_correct (eval)"
      - True: 85% (17)
      - False: 15% (3)
      - Total: 20 scores
    end note
  end

end

deactivate WebUI

User <-- WebUI: æ˜¾ç¤º Trace è¯¦æƒ…\nï¼ˆå«èšåˆ scoresï¼‰

== ç”¨æˆ·äº¤äº’ ==

User -> WebUI: ç‚¹å‡» score aggregate
activate WebUI

WebUI -> WebUI: å±•å¼€ score è¯¦æƒ…\næ˜¾ç¤ºæ‰€æœ‰åŸå§‹ scores

note right of WebUI
  å±•å¼€åæ˜¾ç¤ºï¼š
  - æ‰€æœ‰ scores åˆ—è¡¨
  - æ¯ä¸ª score çš„è¯¦æƒ…ï¼š
    * Value / String Value
    * Comment
    * Source
    * Author (å¦‚æœæ˜¯ ANNOTATION)
    * Timestamp
    * Metadata (å¦‚æœæœ‰)
end note

User <-- WebUI: æ˜¾ç¤ºåŸå§‹ scores
deactivate WebUI

alt å¦‚æœæ˜¯ ANNOTATION source

  User -> WebUI: ç¼–è¾‘ score
  activate WebUI
  
  WebUI -> TRPC: scores.updateAnnotationScore(\n  scoreId, newValue, newComment\n)
  activate TRPC
  
  TRPC -> TRPC: åŸŸå±‚éªŒè¯\nvalidateDbScore()
  
  TRPC -> ScoreRepo: upsertScore(scoreData)
  activate ScoreRepo
  ScoreRepo -> CH: INSERT/UPDATE scores\nWHERE id = ? AND source = 'ANNOTATION'
  activate CH
  return success
  deactivate ScoreRepo
  deactivate TRPC
  
  WebUI <-- TRPC: æ›´æ–°æˆåŠŸ
  
  WebUI -> WebUI: é‡æ–°èšåˆ scores\nåˆ·æ–°æ˜¾ç¤º
  
  deactivate WebUI
  
  User <-- WebUI: æ˜¾ç¤ºæ›´æ–°åçš„ score

end

@enduml
