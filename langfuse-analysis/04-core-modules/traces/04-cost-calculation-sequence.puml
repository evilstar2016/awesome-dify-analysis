@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceArrowColor #1976D2
skinparam sequenceActorBorderColor #426450ff
skinparam sequenceParticipantBorderColor #6C757D
skinparam SequenceParticipantBorderThickness 2
skinparam sequenceLifeLineBorderColor #9bd0f5ff
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #F57C00
skinparam style strictuml
skinparam Padding 6
skinparam ParticipantPadding 30

title 成本计算流程 (Token & Cost Calculation)

participant "Ingestion Worker" as Worker
participant "Ingestion Service" as Service
participant "Model Service" as ModelService
database "Models DB" as ModelsDB
participant "Tokenizer" as Tokenizer
participant "Cost Calculator" as CostCalc
database "ClickHouse" as CH

== Observation 事件处理 ==

Worker -> Service: processObservationEventList(events)
activate Service

Service -> Service: 合并多个事件到单个记录
Service -> Service: mergeObservationRecords()

note right of Service
  将同一 observation 的多次
  更新合并为最终状态
end note

== 模型识别和匹配 ==

Service -> Service: getGenerationUsage({\n  observationRecord,\n  projectId\n})
activate Service

Service -> ModelService: findModel({\n  projectId,\n  modelName: provided_model_name\n})
activate ModelService

ModelService -> ModelsDB: 查询匹配的模型配置
activate ModelsDB

note right of ModelsDB
  使用正则表达式匹配
  model.matchPattern 匹配
  provided_model_name
  
  优先级：
  1. 项目自定义模型
  2. 全局默认模型
end note

ModelsDB --> ModelService: Model + PricingTiers
deactivate ModelsDB

ModelService --> Service: { model, pricingTiers }
deactivate ModelService

== Token 计算 ==

alt 用户提供了 usage_details
  Service -> Service: 使用 provided_usage_details
  
else 需要自动计算 Token
  Service -> Service: getUsageUnits(observationRecord, model)
  activate Service
  
  alt 有输入内容且模型有 tokenizer
    Service -> Tokenizer: tokenCount(input, model)
    activate Tokenizer
    
    note right of Tokenizer
      根据模型的 tokenizerConfig
      使用对应的 tokenizer
      如: openai, anthropic 等
    end note
    
    Tokenizer --> Service: inputTokenCount
    deactivate Tokenizer
  end
  
  alt 有输出内容且模型有 tokenizer
    Service -> Tokenizer: tokenCount(output, model)
    activate Tokenizer
    Tokenizer --> Service: outputTokenCount
    deactivate Tokenizer
  end
  
  Service -> Service: 计算 totalTokens = input + output
  Service --> Service: usage_details = {\n  input, output, total\n}
  deactivate Service
end

== 定价层级匹配 ==

alt 模型有多个定价层级
  Service -> Service: matchPricingTier(\n  pricingTiers,\n  usage_details\n)
  
  note right of Service
    根据 usage_details 匹配定价层级
    按 priority 排序
    检查 conditions:
    - usageType 范围
    - 其他业务条件
  end note
  
  Service -> Service: 选择匹配的 tier
  Service -> Service: 提取 tier.prices
end

== 成本计算 ==

Service -> CostCalc: calculateUsageCosts(\n  modelPrices,\n  provided_cost_details,\n  usage_details\n)
activate CostCalc

alt 用户提供了成本
  CostCalc -> CostCalc: 使用 provided_cost_details
  
  note right of CostCalc
    如果用户提供了任何成本
    则不再计算其他成本
    优先级：用户提供 > 自动计算
  end note
  
  alt 只提供了 input/output cost
    CostCalc -> CostCalc: total = input + output
  end
  
else 自动计算成本
  loop 每个 usage 类型 (input, output, total)
    CostCalc -> CostCalc: 查找对应的 price
    CostCalc -> CostCalc: cost = units × price
    
    note right of CostCalc
      例如：
      inputCost = inputTokens × inputPrice
      outputCost = outputTokens × outputPrice
      
      价格通常以 USD/Million tokens 为单位
    end note
  end
  
  CostCalc -> CostCalc: totalCost = sum of all costs
end

CostCalc --> Service: {\n  cost_details: { input, output, total },\n  total_cost\n}
deactivate CostCalc

Service --> Service: 返回完整的 usage 和 cost 数据
deactivate Service

== 写入 ClickHouse ==

Service -> Service: 更新 observationRecord:\n- usage_details\n- cost_details\n- total_cost\n- internal_model_id\n- usage_pricing_tier_id

Service -> CH: 写入 observations 表
activate CH

note right of CH
  存储字段：
  - usage_details (Map)
  - cost_details (Map)
  - total_cost (Decimal)
  - internal_model_id
  - usage_pricing_tier_id
  - usage_pricing_tier_name
end note

CH --> Service: 写入成功
deactivate CH

Service --> Worker: 处理完成
deactivate Service

note right of Worker
  成本计算完成后:
  1. 前端可以聚合显示总成本
  2. Dashboard 可以按模型分组
  3. 支持按项目/用户统计成本
end note

@enduml
