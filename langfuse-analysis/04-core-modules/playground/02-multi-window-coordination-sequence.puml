@startuml Multi-Window Coordination

title Playground 多窗口协调流程

actor "用户\n(User)" as User
participant "Playground\nPage" as Page
participant "useWindow\nCoordination" as Coord
participant "Window\nRegistry" as Registry
participant "Event\nBus" as EventBus
participant "Window 1\nProvider" as Win1
participant "Window 2\nProvider" as Win2
participant "Window 3\nProvider" as Win3

== 窗口注册阶段 ==

User -> Page: 访问 Playground 页面
activate Page

Page -> Page: 从 LocalStorage 加载\nwindowIds

note right of Page
  LocalStorage key:
  langfuse:playground:windowIds:{projectId}
  
  默认: ["default"]
end note

Page -> Page: 渲染 MultiWindowPlayground\nwindowIds: ["win-1", "win-2", "win-3"]

loop 每个窗口

  Page -> Win1: 渲染 PlaygroundProvider\nwindowId="win-1"
  activate Win1
  
  Win1 -> Win1: useEffect(() => {\n  registerWindow(windowId, handle)\n})
  
  Win1 -> Coord: registerWindow("win-1", handle)
  activate Coord
  
  note right of Coord
    handle: PlaygroundHandle = {
      handleSubmit: (streaming) => {...},
      stopExecution: () => {...},
      getIsStreaming: () => boolean,
      hasModelConfigured: () => boolean
    }
  end note
  
  Coord -> Registry: playgroundWindowRegistry.set(\n  "win-1",\n  handle\n)
  activate Registry
  deactivate Registry
  
  Coord -> Coord: checkModelConfiguration()
  
  note right of Coord
    遍历所有窗口检查：
    hasAnyModelConfigured = 
      registeredWindows.some(h => 
        h.hasModelConfigured()
      )
  end note
  
  Coord -> EventBus: dispatchEvent(\n  WINDOW_REGISTERED,\n  { windowId: "win-1" }\n)
  activate EventBus
  deactivate EventBus
  deactivate Coord
  
  deactivate Win1

end

note right of Registry
  最终 registry 状态：
  Map {
    "win-1" => handle1,
    "win-2" => handle2,
    "win-3" => handle3
  }
end note

Page <-- Coord: 注册完成
deactivate Page

User <-- Page: 显示 3 个窗口

== 添加窗口 ==

User -> Page: 点击 "Add Window" 按钮
activate Page

Page -> Page: addWindowWithCopy(sourceId)

note right of Page
  1. 生成新 windowId: "win-4"
  2. 复制源窗口 cache
  3. 添加到 windowIds 数组
end note

Page -> Page: 从 LocalStorage 读取源窗口 cache\nkey: langfuse:playground:cache:{projectId}:win-3

Page -> Page: 写入新窗口 cache\nkey: langfuse:playground:cache:{projectId}:win-4

Page -> Page: setWindowIds([...windowIds, "win-4"])

Page -> Page: 保存 windowIds 到 LocalStorage

Page -> Page: 重新渲染\nMultiWindowPlayground

Page -> Win3: 渲染新 PlaygroundProvider\nwindowId="win-4"
activate Win3

Win3 -> Win3: 从 cache 加载状态\n（复制自 win-3）

Win3 -> Coord: registerWindow("win-4", handle)
activate Coord

Coord -> Registry: playgroundWindowRegistry.set(\n  "win-4", handle\n)
activate Registry
deactivate Registry

Coord -> EventBus: dispatchEvent(\n  WINDOW_REGISTERED,\n  { windowId: "win-4" }\n)
activate EventBus
deactivate EventBus
deactivate Coord
deactivate Win3

Page -> Page: 自动滚动到新窗口\ncontainerRef.current.scrollTo({\n  left: scrollWidth,\n  behavior: "smooth"\n})
deactivate Page

User <-- Page: 显示新窗口（复制了 win-3 的内容）

== Run All 执行 ==

User -> Page: 点击 "Run All" 按钮
activate Page

Page -> Coord: executeAllWindows()
activate Coord

Coord -> Coord: setIsExecutingAll(true)

Coord -> Registry: 获取所有注册的窗口\nArray.from(registry.entries())
activate Registry
Registry --> Coord: [\n  ["win-1", handle1],\n  ["win-2", handle2],\n  ["win-3", handle3],\n  ["win-4", handle4]\n]
deactivate Registry

Coord -> Coord: 过滤有模型配置的窗口\nwindowsWithModels = windows.filter(\n  ([_, h]) => h.hasModelConfigured()\n)

note right of Coord
  假设 win-2 没有配置模型
  windowsWithModels = [
    ["win-1", handle1],
    ["win-3", handle3],
    ["win-4", handle4]
  ]
end note

alt 无窗口有模型配置
  Coord -> Page: showErrorToast(\n  "No windows have models configured"\n)
  activate Page
  Coord -> Coord: setIsExecutingAll(false)
  deactivate Coord
  Page -> User: 显示错误提示
  deactivate Page
  [<-- User
end

Coord -> EventBus: dispatchEvent(\n  EXECUTE_ALL,\n  { started: true }\n)
activate EventBus
deactivate EventBus

note right of Coord
  创建并行执行 promises：
  
  executions = windowsWithModels.map(
    ([id, handle]) => 
      handle.handleSubmit(true)
        .catch(err => console.error(err))
  )
end note

par 并行执行窗口

  Coord -> Win1: handle.handleSubmit(streaming=true)
  activate Win1
  
  Win1 -> Win1: 执行流程\n（见单窗口执行时序图）
  
  Win1 -> Win1: POST /api/chatCompletion
  Win1 -> Win1: 接收流式响应
  Win1 -> Win1: 更新 output 状态
  
  Win1 --> Coord: 执行完成
  deactivate Win1

else 窗口 3

  Coord -> Win3: handle.handleSubmit(streaming=true)
  activate Win3
  
  Win3 -> Win3: 执行流程
  Win3 -> Win3: POST /api/chatCompletion
  Win3 -> Win3: 接收流式响应
  Win3 -> Win3: 更新 output 状态
  
  Win3 --> Coord: 执行完成
  deactivate Win3

else 窗口 4

  Coord -> Win3: handle.handleSubmit(streaming=true)
  activate Win3
  
  Win3 -> Win3: 执行流程
  Win3 -> Win3: POST /api/chatCompletion
  
  alt 执行失败
    Win3 -> Win3: catch error
    Win3 -> Win3: console.error(\n  "Window win-4 execution failed"\n)
    note right of Win3
      单个窗口失败不影响其他窗口
    end note
  end
  
  Win3 --> Coord: 执行完成/失败
  deactivate Win3

end

Coord -> Coord: await Promise.all(executions)

note right of Coord
  等待所有窗口执行完成
  （无论成功还是失败）
end note

Coord -> Coord: setIsExecutingAll(false)

Coord -> EventBus: dispatchEvent(\n  EXECUTE_ALL,\n  { completed: true }\n)
activate EventBus
deactivate EventBus
deactivate Coord

Page <-- Coord: 全部执行完成
deactivate Page

User <-- Page: 所有窗口显示输出结果

note right of User
  用户可以：
  - 并排对比各窗口输出
  - 选择最佳结果
  - 保存最佳窗口的配置
  - 继续迭代测试
end note

== Stop All 中断 ==

User -> Page: 点击 "Stop All" 按钮\n（执行过程中）
activate Page

Page -> Coord: stopAllWindows()
activate Coord

Coord -> Registry: 遍历所有注册的窗口
activate Registry
Registry --> Coord: 窗口列表
deactivate Registry

loop 每个窗口

  Coord -> Win1: 检查是否正在执行\nif (handle.getIsStreaming())
  activate Win1
  
  alt 正在执行
    Coord -> Win1: handle.stopExecution()
    
    Win1 -> Win1: abortController.abort()
    
    note right of Win1
      触发 AbortError
      中断流式请求
    end note
    
    Win1 -> Win1: setIsStreaming(false)
  end
  
  deactivate Win1

end

Coord -> Coord: setIsExecutingAll(false)

Coord -> EventBus: dispatchEvent(\n  STOP_ALL,\n  { stopped: true }\n)
activate EventBus
deactivate EventBus
deactivate Coord

Page <-- Coord: 全部停止完成
deactivate Page

User <-- Page: 所有窗口停止执行

== 删除窗口 ==

User -> Page: 点击窗口的 "Close" 按钮
activate Page

Page -> Page: removeWindowId("win-2")

note right of Page
  检查窗口数量：
  if (windowIds.length <= 1) {
    // 至少保留一个窗口
    return;
  }
end note

Page -> Page: setWindowIds(\n  windowIds.filter(id => id !== "win-2")\n)

Page -> Page: 保存 windowIds 到 LocalStorage

Page -> Page: 删除窗口 cache\nlocalStorage.removeItem(\n  "langfuse:playground:cache:{projectId}:win-2"\n)

Page -> Page: 重新渲染\nMultiWindowPlayground

Page -> Win2: 卸载 PlaygroundProvider
activate Win2

Win2 -> Win2: useEffect cleanup:\nunregisterWindow("win-2")

Win2 -> Coord: unregisterWindow("win-2")
activate Coord

Coord -> Registry: playgroundWindowRegistry.delete("win-2")
activate Registry
deactivate Registry

Coord -> Coord: checkModelConfiguration()

Coord -> EventBus: dispatchEvent(\n  WINDOW_UNREGISTERED,\n  { windowId: "win-2" }\n)
activate EventBus
deactivate EventBus
deactivate Coord
deactivate Win2

deactivate Page

User <-- Page: 窗口已移除

note right of Registry
  最终 registry 状态：
  Map {
    "win-1" => handle1,
    "win-3" => handle3,
    "win-4" => handle4
  }
end note

@enduml
