# 消息通知集成

## 1. 集成概述

Langfuse 集成多种消息通知服务，用于向用户发送评估结果、系统通知、协作提醒等。支持 Slack、Webhook 和 SMTP 邮件三种主要通知渠道。

### 1.1 使用场景

- **评估通知**: LLM 评估任务完成后通知到 Slack 频道
- **协作提醒**: Trace/Observation 评论 @mentions 邮件通知
- **系统警告**: 使用量告警、账单提醒 (企业版)
- **批量导出**: 导出任务完成邮件通知
- **Webhook 集成**: 实时事件推送到第三方系统

## 2. 支持的服务/产品

| 服务名称 | SDK | 状态 | 优先级 | 用途 |
|---------|-----|------|--------|------|
| **Slack** | `@slack/web-api`, `@slack/oauth` | ✅ 已支持 | ⭐⭐⭐ 核心 | 团队协作通知 |
| **SMTP Email** | `nodemailer` | ✅ 已支持 | ⭐⭐⭐ 核心 | 邮件通知 |
| **Webhook** | Native `fetch` | ✅ 已支持 | ⭐⭐ 重要 | 第三方集成 |

### 2.1 版本信息

```json
{
  "@slack/web-api": "^7.10.0",
  "@slack/oauth": "^3.0.4",
  "nodemailer": "^7.0.11",
  "@react-email/components": "^0.5.1",
  "@react-email/render": "^1.2.1"
}
```

## 3. Slack 集成

### 3.1 架构设计

```
Langfuse Application
    ↓
SlackService
    ↓
@slack/web-api (WebClient)
    ↓
Slack API
```

### 3.2 核心代码路径

```
packages/shared/src/server/services/
└── SlackService.ts                    # Slack 服务实现

web/src/features/slack-integration/
├── server/
│   └── slackIntegrationRouter.ts      # tRPC API
└── components/
    └── SlackIntegrationSettings.tsx   # UI 配置

worker/src/features/slack-integration/
└── sendSlackNotification.ts           # 发送通知
```

### 3.3 SlackService 实现

```typescript
// packages/shared/src/server/services/SlackService.ts
import { WebClient } from "@slack/web-api";
import { InstallProvider } from "@slack/oauth";

export interface SlackMessageParams {
  channel: string;
  text: string;
  blocks?: any[];
  threadTs?: string;  // 回复到特定消息线程
}

export interface SlackChannel {
  id: string;
  name: string;
}

export class SlackService {
  private client: WebClient;

  constructor(accessToken: string) {
    this.client = new WebClient(accessToken);
  }

  /**
   * 发送消息到 Slack 频道
   */
  async sendMessage(params: SlackMessageParams): Promise<SlackMessageResponse> {
    const result = await this.client.chat.postMessage({
      channel: params.channel,
      text: params.text,
      blocks: params.blocks,
      thread_ts: params.threadTs,
    });

    if (!result.ok) {
      throw new Error(`Slack API error: ${result.error}`);
    }

    return {
      channel: result.channel!,
      ts: result.ts!,
      ok: result.ok,
    };
  }

  /**
   * 获取可用的 Slack 频道列表
   */
  async listChannels(): Promise<SlackChannel[]> {
    const result = await this.client.conversations.list({
      types: "public_channel,private_channel",
      limit: 200,
    });

    if (!result.ok || !result.channels) {
      throw new Error("Failed to list Slack channels");
    }

    return result.channels.map(channel => ({
      id: channel.id!,
      name: channel.name!,
    }));
  }

  /**
   * 测试连接
   */
  async testConnection(): Promise<boolean> {
    try {
      const result = await this.client.auth.test();
      return result.ok === true;
    } catch (error) {
      return false;
    }
  }
}
```

### 3.4 OAuth 认证流程

```typescript
// web/src/features/slack-integration/server/slackIntegrationRouter.ts
import { InstallProvider } from "@slack/oauth";

const installer = new InstallProvider({
  clientId: env.SLACK_CLIENT_ID,
  clientSecret: env.SLACK_CLIENT_SECRET,
  stateSecret: env.NEXTAUTH_SECRET,
});

export const slackIntegrationRouter = createTRPCRouter({
  // Step 1: 生成 OAuth URL
  getAuthUrl: protectedProjectProcedure.query(async ({ ctx }) => {
    const url = await installer.generateInstallUrl({
      scopes: ["chat:write", "channels:read", "groups:read"],
      metadata: JSON.stringify({
        projectId: ctx.session.project.id,
        userId: ctx.session.user.id,
      }),
    });

    return { url };
  }),

  // Step 2: 处理 OAuth 回调
  handleCallback: publicProcedure
    .input(z.object({ code: z.string(), state: z.string() }))
    .mutation(async ({ input }) => {
      const installation = await installer.handleCallback({
        code: input.code,
        state: input.state,
      });

      const metadata = JSON.parse(installation.metadata!);

      // 保存到数据库
      await prisma.slackIntegration.create({
        data: {
          projectId: metadata.projectId,
          teamId: installation.team!.id,
          accessToken: encrypt(installation.bot!.token!),
          channelId: null,
          enabled: true,
        },
      });

      return { success: true };
    }),
});
```

### 3.5 发送评估通知示例

```typescript
// worker/src/features/slack-integration/sendSlackNotification.ts
export async function sendEvalJobCompletionNotification(params: {
  projectId: string;
  jobConfigId: string;
  totalScores: number;
  failedScores: number;
}) {
  // 获取 Slack 集成配置
  const integration = await prisma.slackIntegration.findUnique({
    where: {
      projectId: params.projectId,
      enabled: true,
    },
  });

  if (!integration || !integration.channelId) {
    return; // 未配置 Slack
  }

  const accessToken = decrypt(integration.accessToken);
  const slackService = new SlackService(accessToken);

  // 构建消息
  const message = {
    channel: integration.channelId,
    text: `Evaluation job completed`,
    blocks: [
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*Evaluation Job Completed* :white_check_mark:`,
        },
      },
      {
        type: "section",
        fields: [
          {
            type: "mrkdwn",
            text: `*Total Scores:* ${params.totalScores}`,
          },
          {
            type: "mrkdwn",
            text: `*Failed:* ${params.failedScores}`,
          },
        ],
      },
      {
        type: "actions",
        elements: [
          {
            type: "button",
            text: {
              type: "plain_text",
              text: "View Results",
            },
            url: `https://cloud.langfuse.com/project/${params.projectId}/evals/${params.jobConfigId}`,
          },
        ],
      },
    ],
  };

  await slackService.sendMessage(message);
}
```

### 3.6 配置示例

```bash
# Slack OAuth
SLACK_CLIENT_ID="1234567890.1234567890123"
SLACK_CLIENT_SECRET="abcdef1234567890abcdef1234567890"

# Slack 集成存储在数据库中
# - accessToken (加密)
# - channelId
# - teamId
# - enabled
```

## 4. SMTP Email 集成

### 4.1 架构设计

```
Langfuse Application
    ↓
Email Service Functions
    ↓
nodemailer (SMTP Client)
    ↓
SMTP Server (Gmail, SendGrid, AWS SES, etc.)
```

### 4.2 核心代码路径

```
packages/shared/src/server/services/email/
├── batchExportSuccess/
│   ├── BatchExportSuccessEmail.tsx    # React Email 模板
│   └── sendBatchExportSuccessEmail.ts # 发送逻辑
├── commentMention/
│   ├── CommentMentionEmail.tsx
│   └── sendCommentMentionEmail.ts
├── organizationInvitation/
│   ├── OrganizationInvitationEmail.tsx
│   └── sendMembershipInvitationEmail.ts
├── passwordReset/
│   ├── PasswordResetEmail.tsx
│   └── sendPasswordResetEmail.ts
├── cloudSpendAlert/
├── usageThresholdWarning/
└── usageThresholdSuspension/
```

### 4.3 Email 发送实现

```typescript
// packages/shared/src/server/services/email/commentMention/sendCommentMentionEmail.ts
import { createTransport } from "nodemailer";
import { parseConnectionUrl } from "nodemailer/lib/shared/index.js";
import { render } from "@react-email/render";
import CommentMentionEmail from "./CommentMentionEmail";
import { logger } from "../../logger";

export async function sendCommentMentionEmail(params: {
  to: string;
  commenterName: string;
  commentText: string;
  traceUrl: string;
  projectName: string;
}) {
  if (!env.SMTP_CONNECTION_URL) {
    logger.warn("SMTP not configured, skipping email");
    return;
  }

  const connectionConfig = parseConnectionUrl(env.SMTP_CONNECTION_URL);
  const transporter = createTransport(connectionConfig);

  // 使用 React Email 渲染 HTML
  const html = await render(
    CommentMentionEmail({
      commenterName: params.commenterName,
      commentText: params.commentText,
      traceUrl: params.traceUrl,
      projectName: params.projectName,
    })
  );

  // 渲染纯文本版本
  const text = `${params.commenterName} mentioned you in a comment on ${params.projectName}:

"${params.commentText}"

View comment: ${params.traceUrl}`;

  await transporter.sendMail({
    from: env.EMAIL_FROM_ADDRESS || "noreply@langfuse.com",
    to: params.to,
    subject: `${params.commenterName} mentioned you in a comment`,
    text: text,
    html: html,
  });

  logger.info("Comment mention email sent", { to: params.to });
}
```

### 4.4 React Email 模板示例

```typescript
// packages/shared/src/server/services/email/commentMention/CommentMentionEmail.tsx
import {
  Body,
  Button,
  Container,
  Head,
  Html,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface CommentMentionEmailProps {
  commenterName: string;
  commentText: string;
  traceUrl: string;
  projectName: string;
}

export default function CommentMentionEmail({
  commenterName,
  commentText,
  traceUrl,
  projectName,
}: CommentMentionEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>
        {commenterName} mentioned you in a comment
      </Preview>
      <Body style={main}>
        <Container style={container}>
          <Section>
            <Text style={heading}>
              {commenterName} mentioned you in a comment
            </Text>
            <Text style={text}>
              Project: <strong>{projectName}</strong>
            </Text>
            <Text style={comment}>
              "{commentText}"
            </Text>
            <Button style={button} href={traceUrl}>
              View Comment
            </Button>
          </Section>
        </Container>
      </Body>
    </Html>
  );
}

const main = {
  backgroundColor: "#f6f9fc",
  fontFamily: "-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Ubuntu,sans-serif",
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
};

// ... 其他样式
```

### 4.5 配置示例

```bash
# SMTP 配置
SMTP_CONNECTION_URL="smtp://username:password@smtp.gmail.com:587"
EMAIL_FROM_ADDRESS="noreply@langfuse.com"

# 常见 SMTP 提供商
# Gmail:     smtp://username:password@smtp.gmail.com:587
# SendGrid:  smtp://apikey:YOUR_API_KEY@smtp.sendgrid.net:587
# AWS SES:   smtp://AKIAIOSFODNN7EXAMPLE:password@email-smtp.us-east-1.amazonaws.com:587
# Mailgun:   smtp://postmaster@mg.yourdomain.com:password@smtp.mailgun.org:587
```

## 5. Webhook 集成

### 5.1 架构设计

```
Langfuse Event
    ↓
BullMQ Webhook Queue
    ↓
Worker Processor
    ↓
HTTP POST Request
    ↓
Customer Webhook Endpoint
```

### 5.2 核心代码路径

```
packages/shared/src/server/redis/
└── webhookQueue.ts                    # Webhook 队列定义

worker/src/queues/webhookQueue/
├── webhookQueueProcessor.ts           # 处理器
└── types.ts                           # 类型定义

web/src/features/webhooks/
├── server/
│   └── webhookRouter.ts               # tRPC API
└── components/
    └── WebhookSettings.tsx            # UI 配置
```

### 5.3 Webhook 发送实现

```typescript
// worker/src/queues/webhookQueue/webhookQueueProcessor.ts
import { Worker, Job } from "bullmq";
import { getRedis } from "@langfuse/shared/src/server/redis/redis";

interface WebhookPayload {
  webhookId: string;
  url: string;
  secret: string;
  event: string;
  data: Record<string, any>;
}

const worker = new Worker(
  "webhook-queue",
  async (job: Job<WebhookPayload>) => {
    const { url, secret, event, data } = job.data;

    const payload = {
      event: event,
      timestamp: new Date().toISOString(),
      data: data,
    };

    // 生成签名 (HMAC-SHA256)
    const signature = createHmac("sha256", secret)
      .update(JSON.stringify(payload))
      .digest("hex");

    // 发送 HTTP POST 请求
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Langfuse-Signature": signature,
        "X-Langfuse-Event": event,
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Webhook failed: ${response.status} ${response.statusText}`);
    }

    logger.info("Webhook delivered", {
      webhookId: job.data.webhookId,
      event: event,
      status: response.status,
    });
  },
  {
    connection: getRedis(),
    concurrency: 10,
    limiter: {
      max: 100,
      duration: 1000,
    },
  }
);

// 重试策略
worker.on("failed", async (job, error) => {
  logger.error("Webhook failed", {
    jobId: job?.id,
    error: error.message,
    attempt: job?.attemptsMade,
  });

  // BullMQ 自动重试，指数退避
});
```

### 5.4 支持的事件类型

```typescript
export enum WebhookEvent {
  TraceCreated = "trace.created",
  TraceUpdated = "trace.updated",
  ScoreCreated = "score.created",
  EvalJobCompleted = "eval_job.completed",
  DatasetItemCreated = "dataset_item.created",
}
```

### 5.5 Webhook 签名验证 (客户端)

```typescript
// 客户端验证 Langfuse Webhook
import { createHmac } from "crypto";

export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = createHmac("sha256", secret)
    .update(payload)
    .digest("hex");

  return signature === expectedSignature;
}

// Express 中间件示例
app.post("/webhook/langfuse", express.raw({ type: "application/json" }), (req, res) => {
  const signature = req.headers["x-langfuse-signature"] as string;
  const payload = req.body.toString();

  if (!verifyWebhookSignature(payload, signature, WEBHOOK_SECRET)) {
    return res.status(401).send("Invalid signature");
  }

  const event = JSON.parse(payload);
  console.log("Received webhook:", event);

  res.status(200).send("OK");
});
```

### 5.6 配置示例

```typescript
// 在数据库中配置 (通过 Web UI)
{
  "webhookId": "webhook-123",
  "projectId": "project-456",
  "url": "https://example.com/webhook/langfuse",
  "secret": "whsec_...",  // 加密存储
  "events": ["trace.created", "score.created"],
  "enabled": true
}
```

## 6. 使用示例

### 6.1 发送 Slack 通知

```typescript
import { SlackService } from "@langfuse/shared/src/server/services/SlackService";

const slackService = new SlackService(accessToken);

await slackService.sendMessage({
  channel: "C1234567890",
  text: "Evaluation completed!",
  blocks: [
    {
      type: "section",
      text: {
        type: "mrkdwn",
        text: "*Evaluation completed* :tada:",
      },
    },
  ],
});
```

### 6.2 发送邮件

```typescript
import { sendCommentMentionEmail } from "@langfuse/shared/src/server/services/email/commentMention/sendCommentMentionEmail";

await sendCommentMentionEmail({
  to: "user@example.com",
  commenterName: "Alice",
  commentText: "Great job on this trace!",
  traceUrl: "https://cloud.langfuse.com/project/123/traces/456",
  projectName: "My Project",
});
```

### 6.3 触发 Webhook

```typescript
import { enqueueWebhook } from "@langfuse/shared/src/server/redis/webhookQueue";

await enqueueWebhook({
  webhookId: "webhook-123",
  url: "https://example.com/webhook",
  secret: webhookSecret,
  event: "trace.created",
  data: {
    traceId: "trace-456",
    projectId: "project-789",
    name: "API Call",
    userId: "user-123",
  },
});
```

## 7. 最佳实践

### 7.1 错误处理

- 使用重试机制 (Webhook 通过 BullMQ 自动重试)
- 记录失败日志用于排查
- 提供用户友好的错误提示

### 7.2 性能优化

- 异步发送通知 (使用队列)
- 批量发送 (合并多个通知)
- 控制发送频率 (避免垃圾通知)

### 7.3 安全

- Webhook 使用 HMAC 签名验证
- SMTP 密码加密存储
- Slack Token 加密存储

## 8. 相关资源

- **Slack API 文档**: https://api.slack.com/
- **Nodemailer 文档**: https://nodemailer.com/
- **React Email 文档**: https://react.email/

---

**更新日期**: 2025-12-17  
**维护者**: Langfuse Engineering Team
