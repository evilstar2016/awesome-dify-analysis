# 认证授权集成

## 1. 集成概述

Langfuse 使用 **NextAuth.js (Auth.js)** 作为统一的认证框架,支持多种认证提供商,包括传统的邮箱密码登录、OAuth 社交登录和企业级 SSO (单点登录)。

### 1.1 认证策略

- **多提供商支持**: 社交登录、SSO、邮箱密码
- **会话管理**: JWT + 数据库会话
- **RBAC**: 基于角色的访问控制
- **API Key 认证**: 用于 SDK 和 API 访问

### 1.2 授权模型

```
Organization (组织)
    ↓
Projects (项目)
    ↓
Members (成员) + Roles (角色)
    ↓
Permissions (权限)
```

## 2. 支持的服务/产品

| 认证提供商 | Provider | 状态 | 优先级 | 类型 |
|-----------|----------|------|--------|------|
| **Email + Password** | Credentials | ✅ 已支持 | ⭐⭐⭐ 核心 | 传统认证 |
| **Google** | Google | ✅ 已支持 | ⭐⭐⭐ 核心 | OAuth 2.0 |
| **GitHub** | GitHub | ✅ 已支持 | ⭐⭐⭐ 核心 | OAuth 2.0 |
| **GitLab** | GitLab | ✅ 已支持 | ⭐⭐ 重要 | OAuth 2.0 |
| **Okta** | Okta | ✅ 已支持 | ⭐⭐ 重要 | SSO (OIDC) |
| **Azure AD** | Azure AD | ✅ 已支持 | ⭐⭐ 重要 | SSO (OIDC) |
| **GitHub Enterprise** | Custom | ✅ 已支持 | ⭐⭐ 重要 | OAuth 2.0 |
| **Authentik** | Authentik | ✅ 已支持 | ⭐ 可选 | SSO (OIDC) |
| **JumpCloud** | Custom | ✅ 已支持 | ⭐ 可选 | SSO (OIDC) |
| **OneLogin** | OneLogin | ✅ 已支持 | ⭐ 可选 | SSO (OIDC) |
| **Custom SSO** | Custom OIDC | ✅ 已支持 | ⭐ 可选 | SSO (OIDC) |

### 2.1 版本信息

```json
{
  "next-auth": "^4.24.12",
  "@next-auth/prisma-adapter": "^1.0.7",
  "bcryptjs": "^2.4.3"
}
```

## 3. NextAuth.js 配置

### 3.1 核心代码路径

```
web/src/pages/api/auth/
└── [...nextauth].ts                   # NextAuth 配置入口

packages/shared/src/server/auth/
├── apiKeys.ts                         # API Key 认证
├── userProjectRoleAuth.ts             # RBAC 授权
├── customSsoProvider.ts               # 自定义 SSO
├── gitHubEnterpriseProvider.ts        # GitHub Enterprise
└── jumpcloudProvider.ts               # JumpCloud SSO

web/src/features/auth/
├── components/
│   ├── SignInForm.tsx
│   ├── SignUpForm.tsx
│   └── SsoConfigForm.tsx
└── server/
    └── authRouter.ts                  # tRPC 认证 API
```

### 3.2 NextAuth 配置实现

```typescript
// web/src/pages/api/auth/[...nextauth].ts
import NextAuth, { type NextAuthOptions } from "next-auth";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import GitHubProvider from "next-auth/providers/github";
import GitLabProvider from "next-auth/providers/gitlab";
import OktaProvider from "next-auth/providers/okta";
import { compare } from "bcryptjs";
import { prisma } from "@langfuse/shared/src/db";
import { env } from "@/src/env.mjs";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  
  // Session 策略
  session: {
    strategy: "jwt",  // 使用 JWT，性能更好
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },

  // Providers
  providers: [
    // 邮箱密码登录
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Invalid credentials");
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isValid = await compare(credentials.password, user.password);

        if (!isValid) {
          throw new Error("Invalid credentials");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          image: user.image,
        };
      },
    }),

    // Google OAuth
    ...(env.AUTH_GOOGLE_CLIENT_ID
      ? [
          GoogleProvider({
            clientId: env.AUTH_GOOGLE_CLIENT_ID,
            clientSecret: env.AUTH_GOOGLE_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true,
          }),
        ]
      : []),

    // GitHub OAuth
    ...(env.AUTH_GITHUB_CLIENT_ID
      ? [
          GitHubProvider({
            clientId: env.AUTH_GITHUB_CLIENT_ID,
            clientSecret: env.AUTH_GITHUB_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true,
          }),
        ]
      : []),

    // GitLab OAuth
    ...(env.AUTH_GITLAB_CLIENT_ID
      ? [
          GitLabProvider({
            clientId: env.AUTH_GITLAB_CLIENT_ID,
            clientSecret: env.AUTH_GITLAB_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true,
          }),
        ]
      : []),

    // Okta SSO
    ...(env.AUTH_OKTA_CLIENT_ID
      ? [
          OktaProvider({
            clientId: env.AUTH_OKTA_CLIENT_ID,
            clientSecret: env.AUTH_OKTA_CLIENT_SECRET,
            issuer: env.AUTH_OKTA_ISSUER,
          }),
        ]
      : []),

    // ... 其他提供商
  ],

  // Callbacks
  callbacks: {
    async jwt({ token, user, account }) {
      if (user) {
        token.id = user.id;
        token.email = user.email;
      }
      return token;
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.email = token.email as string;
      }
      return session;
    },

    async signIn({ user, account, profile }) {
      // 自定义登录逻辑
      // 例如: 域名白名单验证
      if (env.AUTH_DOMAINS_WITH_SSO_ENFORCEMENT) {
        const domains = env.AUTH_DOMAINS_WITH_SSO_ENFORCEMENT.split(",");
        const userDomain = user.email?.split("@")[1];
        
        if (domains.includes(userDomain!) && account?.provider === "credentials") {
          // 强制该域名使用 SSO
          return false;
        }
      }

      return true;
    },
  },

  pages: {
    signIn: "/auth/signin",
    error: "/auth/error",
  },

  events: {
    async signIn({ user, account, isNewUser }) {
      // 记录登录事件
      logger.info("User signed in", {
        userId: user.id,
        provider: account?.provider,
        isNewUser,
      });
    },
  },

  debug: env.NODE_ENV === "development",
};

export default NextAuth(authOptions);
```

## 4. OAuth 社交登录

### 4.1 Google OAuth 配置

```bash
# 环境变量
AUTH_GOOGLE_CLIENT_ID="123456789-abc.apps.googleusercontent.com"
AUTH_GOOGLE_CLIENT_SECRET="GOCSPX-..."

# Google Cloud Console 配置
# 1. 创建 OAuth 2.0 客户端 ID
# 2. 授权重定向 URI: https://your-domain.com/api/auth/callback/google
# 3. 获取 Client ID 和 Client Secret
```

### 4.2 GitHub OAuth 配置

```bash
# 环境变量
AUTH_GITHUB_CLIENT_ID="Iv1.1234567890abcdef"
AUTH_GITHUB_CLIENT_SECRET="abcdef1234567890abcdef1234567890abcdef12"

# GitHub Settings 配置
# 1. Developer settings > OAuth Apps > New OAuth App
# 2. Authorization callback URL: https://your-domain.com/api/auth/callback/github
# 3. 获取 Client ID 和 Client Secret
```

### 4.3 GitLab OAuth 配置

```bash
AUTH_GITLAB_CLIENT_ID="..."
AUTH_GITLAB_CLIENT_SECRET="..."
AUTH_GITLAB_ISSUER="https://gitlab.com"  # 或自托管 GitLab URL
```

## 5. 企业 SSO 集成

### 5.1 Okta SSO 配置

```bash
# 环境变量
AUTH_OKTA_CLIENT_ID="0oa..."
AUTH_OKTA_CLIENT_SECRET="..."
AUTH_OKTA_ISSUER="https://your-domain.okta.com"

# Okta 配置步骤
# 1. Applications > Create App Integration > OIDC
# 2. Application type: Web Application
# 3. Sign-in redirect URIs: https://your-domain.com/api/auth/callback/okta
# 4. 获取 Client ID, Client Secret, Issuer URL
```

### 5.2 Azure AD / Entra ID 配置

```bash
AUTH_AZURE_AD_CLIENT_ID="..."
AUTH_AZURE_AD_CLIENT_SECRET="..."
AUTH_AZURE_AD_TENANT_ID="..."

# Azure Portal 配置
# 1. Azure Active Directory > App registrations > New registration
# 2. Redirect URI: https://your-domain.com/api/auth/callback/azure-ad
# 3. Certificates & secrets > New client secret
# 4. API permissions > Microsoft Graph > User.Read
```

### 5.3 自定义 SSO Provider (OIDC)

```typescript
// packages/shared/src/server/auth/customSsoProvider.ts
export function createCustomSsoProvider(config: {
  id: string;
  name: string;
  clientId: string;
  clientSecret: string;
  issuer: string;
  wellKnown?: string;
}): OIDCConfig<any> {
  return {
    id: config.id,
    name: config.name,
    type: "oidc",
    clientId: config.clientId,
    clientSecret: config.clientSecret,
    issuer: config.issuer,
    wellKnown: config.wellKnown,
    authorization: {
      params: {
        scope: "openid email profile",
      },
    },
    profile(profile) {
      return {
        id: profile.sub,
        email: profile.email,
        name: profile.name,
        image: profile.picture,
      };
    },
  };
}
```

### 5.4 JumpCloud SSO 配置

```typescript
// packages/shared/src/server/auth/jumpcloudProvider.ts
import { createCustomSsoProvider } from "./customSsoProvider";

export const JumpCloudProvider = (config: {
  clientId: string;
  clientSecret: string;
}) => {
  return createCustomSsoProvider({
    id: "jumpcloud",
    name: "JumpCloud",
    clientId: config.clientId,
    clientSecret: config.clientSecret,
    issuer: "https://oauth.id.jumpcloud.com",
  });
};
```

## 6. API Key 认证

### 6.1 API Key 模型

```prisma
// packages/shared/prisma/schema.prisma
model ApiKey {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  note              String?
  publicKey         String   @unique
  hashedSecretKey   String   @unique
  displaySecretKey  String   // 脱敏显示: "sk-lf-...abc123"
  lastUsedAt        DateTime?
  expiresAt         DateTime?
  
  projectId         String
  project           Project  @relation(fields: [projectId], references: [id])
}
```

### 6.2 API Key 生成

```typescript
// packages/shared/src/server/auth/apiKeys.ts
import { hash } from "bcryptjs";
import { randomBytes } from "crypto";

export async function createApiKey(params: {
  projectId: string;
  note?: string;
  expiresAt?: Date;
}) {
  // 生成密钥
  const secretKey = `sk-lf-${randomBytes(32).toString("hex")}`;
  const publicKey = `pk-lf-${randomBytes(16).toString("hex")}`;

  // Hash 密钥
  const hashedSecretKey = await hash(secretKey, 12);

  // 脱敏显示
  const displaySecretKey = `${secretKey.slice(0, 9)}...${secretKey.slice(-6)}`;

  // 保存到数据库
  const apiKey = await prisma.apiKey.create({
    data: {
      projectId: params.projectId,
      publicKey,
      hashedSecretKey,
      displaySecretKey,
      note: params.note,
      expiresAt: params.expiresAt,
    },
  });

  // 只返回一次完整密钥
  return {
    ...apiKey,
    secretKey, // 仅首次返回
  };
}
```

### 6.3 API Key 验证

```typescript
// packages/shared/src/server/auth/apiKeys.ts
import { compare } from "bcryptjs";

export async function verifyApiKey(secretKey: string): Promise<{
  valid: boolean;
  projectId?: string;
  apiKeyId?: string;
}> {
  // 查找所有 API Key
  const apiKeys = await prisma.apiKey.findMany({
    where: {
      expiresAt: {
        OR: [
          { gt: new Date() },
          { equals: null },
        ],
      },
    },
    select: {
      id: true,
      projectId: true,
      hashedSecretKey: true,
    },
  });

  // 验证密钥
  for (const apiKey of apiKeys) {
    const isValid = await compare(secretKey, apiKey.hashedSecretKey);
    
    if (isValid) {
      // 更新最后使用时间
      await prisma.apiKey.update({
        where: { id: apiKey.id },
        data: { lastUsedAt: new Date() },
      });

      return {
        valid: true,
        projectId: apiKey.projectId,
        apiKeyId: apiKey.id,
      };
    }
  }

  return { valid: false };
}
```

### 6.4 API Key 使用示例

```typescript
// SDK 或 API 请求
const response = await fetch("https://cloud.langfuse.com/api/public/traces", {
  method: "GET",
  headers: {
    "Authorization": "Bearer sk-lf-...",
    "Content-Type": "application/json",
  },
});

// Web API 中间件验证
export async function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader?.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing API key" });
  }

  const apiKey = authHeader.substring(7);
  const { valid, projectId } = await verifyApiKey(apiKey);

  if (!valid) {
    return res.status(401).json({ error: "Invalid API key" });
  }

  req.projectId = projectId;
  next();
}
```

## 7. RBAC 授权

### 7.1 角色定义

```prisma
enum MembershipRole {
  OWNER      // 组织所有者
  ADMIN      // 管理员
  MEMBER     // 普通成员
  VIEWER     // 只读成员
}
```

### 7.2 权限检查

```typescript
// packages/shared/src/server/auth/userProjectRoleAuth.ts
export async function hasProjectAccess(params: {
  userId: string;
  projectId: string;
  minRole?: MembershipRole;
}): Promise<boolean> {
  const membership = await prisma.projectMembership.findFirst({
    where: {
      userId: params.userId,
      project: {
        id: params.projectId,
      },
    },
    include: {
      organization: {
        include: {
          memberships: {
            where: { userId: params.userId },
          },
        },
      },
    },
  });

  if (!membership) {
    return false;
  }

  // 检查角色权限
  if (params.minRole) {
    const roleHierarchy = {
      VIEWER: 1,
      MEMBER: 2,
      ADMIN: 3,
      OWNER: 4,
    };

    const userRole = membership.organization.memberships[0]?.role;
    if (!userRole) return false;

    return roleHierarchy[userRole] >= roleHierarchy[params.minRole];
  }

  return true;
}
```

### 7.3 tRPC 授权中间件

```typescript
// web/src/server/api/trpc.ts
export const protectedProjectProcedure = publicProcedure
  .input(z.object({ projectId: z.string() }))
  .use(async ({ ctx, input, next }) => {
    if (!ctx.session?.user?.id) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }

    const hasAccess = await hasProjectAccess({
      userId: ctx.session.user.id,
      projectId: input.projectId,
    });

    if (!hasAccess) {
      throw new TRPCError({ code: "FORBIDDEN" });
    }

    return next({
      ctx: {
        ...ctx,
        session: ctx.session,
        projectId: input.projectId,
      },
    });
  });
```

## 8. 配置示例

### 8.1 完整环境变量

```bash
# NextAuth
NEXTAUTH_URL="https://your-domain.com"
NEXTAUTH_SECRET="your-super-secret-key-min-32-chars"

# OAuth Providers
AUTH_GOOGLE_CLIENT_ID="..."
AUTH_GOOGLE_CLIENT_SECRET="..."
AUTH_GITHUB_CLIENT_ID="..."
AUTH_GITHUB_CLIENT_SECRET="..."
AUTH_GITLAB_CLIENT_ID="..."
AUTH_GITLAB_CLIENT_SECRET="..."

# Enterprise SSO
AUTH_OKTA_CLIENT_ID="..."
AUTH_OKTA_CLIENT_SECRET="..."
AUTH_OKTA_ISSUER="https://your-domain.okta.com"

AUTH_AZURE_AD_CLIENT_ID="..."
AUTH_AZURE_AD_CLIENT_SECRET="..."
AUTH_AZURE_AD_TENANT_ID="..."

# Custom SSO
AUTH_CUSTOM_CLIENT_ID="..."
AUTH_CUSTOM_CLIENT_SECRET="..."
AUTH_CUSTOM_ISSUER="..."

# 域名 SSO 强制
AUTH_DOMAINS_WITH_SSO_ENFORCEMENT="company.com,enterprise.com"

# 禁用注册 (仅邀请)
AUTH_DISABLE_SIGNUP="false"
```

## 9. 最佳实践

### 9.1 安全

1. **密钥管理**
   - 使用强随机密钥生成 NEXTAUTH_SECRET
   - 定期轮换 API Keys
   - Hash 存储密码和 API Keys

2. **会话管理**
   - 设置合理的会话过期时间
   - 实现会话撤销机制
   - 使用 HTTPS

3. **OAuth 安全**
   - 验证 Redirect URIs
   - 使用 state 参数防止 CSRF
   - 启用 PKCE (Proof Key for Code Exchange)

### 9.2 用户体验

1. **SSO 自动跳转**
   ```typescript
   // 根据邮箱域名自动选择 SSO 提供商
   if (emailDomain === "company.com") {
     return signIn("okta");
   }
   ```

2. **记住登录状态**
   ```typescript
   session: {
     maxAge: 30 * 24 * 60 * 60, // 30 days
   }
   ```

## 10. 相关资源

- **NextAuth.js 文档**: https://next-auth.js.org/
- **OAuth 2.0 规范**: https://oauth.net/2/
- **OIDC 规范**: https://openid.net/connect/

---

**更新日期**: 2025-12-17  
**维护者**: Langfuse Engineering Team
